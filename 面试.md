# C#

### 值类型和引用类型的区别
- 速度上的区别:值类型存取速度快，引用类型存取速度慢。
- 用途上的区别:值类型表示实际数据，引用类型表示指向存储在内存中的数据的指针或引用。
- 来源上的区别:值类型继承自System.ValueType，引用类型继承自System.Object
- 位置上的区别:值类型的数据存储在内存的栈中，引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。
- 类型上的区别:值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。
- 值类型和引用类型在内存上存储的地方不一样。值类型的值是存储在内存的栈当中。引用类型的值是存储在内存的堆中。
- 在传递值类型和传递引用类型的时候，传递方式不一样。值类型我们称之为值传递，引用类型我们称之为引用传递。
- 值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。
- 引用类型（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。

### 拆箱装箱
装箱（boxing）和拆箱（unboxing）是C#类型系统的核心概念.是不同于C与C++的新概念！,通过装箱和拆箱操作，能够在值类型和引用类型中架起一做桥梁.换言之,可以轻松的实现值类型与引用类型的互相转换,装箱和拆箱能够统一考察系统,任何类型的值最终都可以按照对象进行处理.
- 装箱 就是把“值类型”转换成“引用类型”(Object)
- 拆箱 就是把“引用类型”转换成“值类型”

### c#中的数组、ArrayList、List区别
https://www.cnblogs.com/newcapecjmc/p/6970220.html

- 数组

  - 在内存上连续存储查询很快
  - 在数组的两个数据间插入数据是很麻烦的，而且在声明数组的时候必须指定数组的长度，数组的长度过长，会造成内存浪费，过段会造成数据溢出的错误。如果在声明数组时我们不清楚数组的长度，就会变得很麻烦。

- ArrayList

  - 基本是解决了数组的问题，但引入了新的问题

  - ArrayList会把所有插入其中的数据当作为object类型来处理，在我们使用ArrayList处理数据时，很可能会报类型不匹配的错误，也就是ArrayList不是类型安全的。在存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损。

- **泛型List**

  - 在声明List集合时，我们同时需要为其声明List集合内数据的对象类型，避免了arraylist的问题

### C#中字典集合HashTable、Dictionary、ConcurrentDictionary三者区别
https://www.cnblogs.com/yinrq/p/5584885.html

- HashTable

- - 用于处理和表现类似key-value的键值对，其中key通常可用来快速查找，同时key是区分大小写；value用于存储对应于key的值。Hashtable中key-value键值对均为object类型，所以Hashtable可以支持任何类型的keyvalue键值对，任何非 null 对象都可以用作键或值。

    HashTable是一种散列表，他内部维护很多对Key-Value键值对，其还有一个类似索引的值叫做散列值(HashCode)，它是根据GetHashCode方法对Key通过一定算法获取得到的，所有的查找操作定位操作都是基于散列值来实现找到对应的Key和Value值的。

    散列函数(GetHashCode)让散列值对应HashTable的空间地址尽量不重复。

    当一个HashTable被占用一大半的时候我们通过计算散列值取得的地址值可能会重复指向同一地址，这就造成哈希冲突。

    *C#中键值对在HashTable中的位置Position= (HashCode& 0x7FFFFFFF) % HashTable.Length，C#是通过探测法解决哈希冲突的，当通过散列值取得的位置Postion以及被占用的时候，就会增加一个位移x值判断下一个位置Postion+x是否被占用，如果仍然被占用就继续往下位移x判断Position+2\*x位置是否被占用，如果没有被占用则将值放入其中。当HashTable中的可用空间越来越小时，则获取得到可用空间的难度越来越大，消耗的时间就越多。*

  

  - Dictionary<TKey, TValue> 泛型类提供了从一组键到一组值的映射。通过键来检索值的速度是非常快的，接近于 O(1)，这是因为 Dictionary<TKey, TValue> 类是作为一个哈希表来实现的。检索速度取决于为 TKey 指定的类型的哈希算法的质量。TValue可以是值类型，数组，类或其他。

    Dictionary是一种变种的HashTable,它采用一种分离链接散列表的数据结构来解决哈希冲突的问题。




### C#List(链表)Dictionary(字典)源码剖析[Unity内功修炼-C#进阶01] - 修勾的文章 - 知乎
https://zhuanlan.zhihu.com/p/634380627

### 抽象类和接口的异同
**相同点：**
1. 都不能被实例化
2. 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化

**不同点**

1. 接口只有定义，其方法不能再接口中实现，只有实现接口的类才能实现接口中定义的方    法，而抽象类的方法可以再抽象类中被实现。
2. 接口需要用implements实现,抽象类只能被继承（extends）。
3. 设计理念不同，接口是"has - a "，抽象类是"is -a "
4. 接口中定义的成员变量默认修饰符为public static final（静态不能被修改），而且必须      给其赋初值。抽象类可以有自己的数据成员变量，也可以有非抽象的成员变量，而且抽象类中的成员变量默认为default(本包可见)。抽象类中的方法前面有abstract修饰，不能用private、static、synchronize、native修饰，同时方法必须以分号结尾，不带花括号。

### 什么时候用对象什么时候用接口?
抽象类是对类的抽象，接口是对行为的抽象。
如果行为跨越不同类的对象，可使用接口，对于一些现实的类对象，用继承抽象类。
抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。


### in out ref
- in 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它类似于 ref 或 out 关键字，不同之处在于 in 参数无法通过调用的方法进行修改。
- out 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它与 ref 关键字相似，只不过 ref 要求在传递之前初始化变量。 它也类似于 in 关键字，只不过 in 不允许通过调用方法来修改参数值。 若要使用 out 参数，方法定义和调用方法均必须显式使用 out 关键字。
- ref该种类型的参数传递变量地址给方法（引用传递），传递前变量必须初始化。 该类型与out型的区别在与： 1）.ref型传递变量前，变量必须初始化，否则编译器会报错,而out型则不需要初始化 2）.ref型传递变量，数值可以传入方法中，而out型无法将数据传入方法中。换而言之，ref型有进有出，out型只出不进。

``` C#
class Test
{
    static void Main(string[] args)
    {
        InOutRef test = new InOutRef();
        string outString = "10"; // out在函数外也可以赋值
        string refString = "1"; // ref不初始化会报错
        test.Test(1, out outString,ref refString);
    }
}

class InOutRef
{
    public void Test(in int inTest ,out string outTest,ref string refTest)
    {

        outTest = "10"; // out在函数内不赋值会报错
    }
}
```

### C#反射
C#反射机制
https://zhuanlan.zhihu.com/p/41282759




### 委托
C#各种委托介绍
https://www.cnblogs.com/oneweek/p/11236811.html

### C#字符串复制
- 复制是通过Copy和CopyTo来实现的。string.Copy(要复制的字符串);CopyTo(要复制字符的起始位置(从第几个字符开始往后复制（不包括第几个字符）)，目标字符数组，目标数组中的开始存放位置，要复制的字符个数);

### 介绍const？const修饰成员函数时放在哪？

`const` 表示**编译时常量**：值在编译期就确定，编译器在引用处直接把字面值嵌入到调用方代码或元数据

- 修饰不变常量，在编译的时候就需要有确定的值，只能用于数值和字符串，或者引用类型只能为null，struct也不能用const标记。const可以修饰class的字段或者局部变量，不能修饰属性。而readonly仅仅用于修饰class的字段，不能修饰属性。const是属于类级别而不是实例对象级别，不能跟static一起使用。而readonly既可以是类级别也可以是实例级别，它可以与static一起使用。
- readonly是只读的意思，表示不能进行写操作。最重要的是它在程序运行时才会去求值。它可以是任意类型，当然可以是object，数组，struct，它必须在构造函数或者初始化器中初始化，初始化完成之后不能被修改。通常可以定义一个readonly值为DateTime的常量。而const却无法指定为DateTime类型。
- 只有C#内置类型（int,double,long等）可以声明为const;结果、类和数组不能声明为const。
- readonly 是在字段上使用的修饰符，直接以类名.字段访问。
- const 必须在申明中初始化。之后不能再修改。
- readonly可以在申明中初始化，也可以在构造函数中初始化，其它情况不能修改。

### 函数可以返回引用吗？为什么？
- 引用就是变量的别名，操作一个变量的引用也就相当于操作变量本身，这一点跟指针很类似，但是操作引用不用像操作指针一样，利用取地址符号，很不方便。而操作引用的话，则跟操作普通变量一样，所以C++之中更加鼓励使用引用。
- C语言之中大量利用指针作为形参或者函数返回值，这是由于值拷贝会有很大的消耗（比如传入传出一个大的结构体）。所以在C++之中使用引用作为函数参数和返回值的目的和使用指针是一样的。而且形式上更加直观，所以C++提倡使用引用。
- 使用引用当作函数参数和返回值，效率更高。
- 函数返回的对象引用，必须在调用函数前就已经存在，不允许返回局部变量的引用！
- 当不希望返回的对象被修改的时候，可以添加const。

### 结构体和类的区别
- 类是引用类型，结构是值类型。
- 结构不支持继承。
- 结构不能声明默认的构造函数。

### 常用数据结构时间复杂度
![](img/时间复杂度.png)

### 闭包

当发生闭包时是这样的现象——先是捕获到变量，把它的存储位置提取出来让闭包内外都可以访问到；然后编译器将生成一个私有的匿名封装类，将捕获到的变量作为字段，lambda的方法体作为类的实例方法，返回的委托指向这个实例对象的函数，因此啊这个对象存储在堆上。

**概念**
内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。但该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。

**条件**
闭包是将一些执行语句的封装，可以将封装的结果像对象一样传递，在传递时,这个封装依然能够访问到原上下文。 
  形成闭包有一些值得总结的非必要条件： 
  1、嵌套定义的函数。 
  2、匿名函数。 
  3、将函数作为参数或者返回值。 
  4、在.NET中，可以通过匿名委托形成闭包：函数可以作为参数传递，也可以作为返回值返回，或者作为函数变量。而在.NET中，这都可以通过委托来实现。这些是实现闭包的前提。

### C# GC
**基本概念**

- CLR: Common Language Runtime, 公共语言运行时，是一种可以支持多种语言的运行时，其基本的核心功能包含:
    - 内存管理
    - 程序集加载和卸载
    - 类型安全
    - 异常处理
    - 线程同步

![f46ea4a64f73e366de414ff73fc9b178.png](img/4888_1.png)
- 托管模块的基本组成:
    - PE32/PE32+(64位)
    - CLR头
    - 元数据
    - IL代码(托管代码)
    
- 引用类型和值类型
    - 这部分略过，基本都有相关的认识，本质是看其分配的内存位于内存堆上还是栈上。
    - 每个进程会分配一个对应的进程堆，这就是我们常说的程序内存申请区域，不同进程是不会有交叉的。在堆上还是在栈上进行内存分配，是没有速度差异的，都很快。
    
- 垃圾回收器(Garbage Collector)
    - 在CLR中的自动内存管理，就会使用垃圾回收器来执行内存管理，其会定时执行，或者在申请内存分配是发现内存不足时触发执行，也可以手动触发执行(System.GC.Collect)
    - 垃圾回收的几种基本算法
        - 标记清除算法(Mark-Sweep)关键点是，清除后，并不会执行内存的压缩
        - 复制算法(Copying) 内存等额划分，每次执行垃圾回收后，拷贝不被回收的内存到没有被使用的内存块，自带内存压缩，弊端是内存浪费大(每次只能使用部分，预留部分给拷贝使用)
        - 标记整理算法(Mark-Compact)关键点，清除后，会执行内存压缩，不会有内存碎片
        - 分代收集算法(Generational Collection)对内存对象进行分代标记，避免全量垃圾回收带来的性能消耗。下文会详细讲解。

**垃圾回收模型**

- 垃圾回收的目的
    - 缘由： 内存是有限的，为了避免内存溢出，需要清理无效内存
- 触发时机
    - 申请分配内存时内存不足(本身不足或者内存碎片过多没有足够大小的内存片)
    - 强制调用System.GC.Collect
    - CLR卸载应用程序域(AppDomain)
    - CLR正在关闭(后面2种在进程运行时不会触发)
- 垃圾回收的流程
    - GC准备阶段 暂停进程中的所有线程，避免线程在CLR检测根期间访问堆内存
    - GC的标记阶段 首先，会默认托管堆上所有的对象都是垃圾(可回收对象)，然后开始遍历根对象并构建一个由所有和根对象之间有引用关系的对象构成的对象图，然后GC会挨个遍历根对象和其引用对象，如果根对象没有任何引用对象(null)GC会忽略该根对象。对于含有引用对象的根对象以及其引用对象，GC将其纳入对象图中，如果发现已经处于对象图中，则换一个路径遍历，避免无限循环。PS： 所有的全局和静态对象指针是应用程序的根对象。
    - 垃圾回收阶段 完成遍历操作后，对于没有被纳入对象图中的对象，执行清理操作
    - 碎片整理阶段 如果垃圾回收算法包含这个阶段，则会对剩下的保留的对象进行一次内存整理，重新归类到堆内存中，相应的引用地址也会对应的整理，避免内存碎片的产生。
    

![c9080d88c233905b46803105fc1ba3d4.png](img/4890_1.png)

- 分代垃圾回收的过程
    - 分代的基本设计思路:
        - 对象越新，生命周期越短，反之也成立
        - 回收托管堆的一部分，性能和速度由于回收整个托管堆
    - 基本的分代: 0/1/2：
        - 0代: 从未被标记为回收的新分配对象
        - 1代: 上一次垃圾回收中没有被回收的对象
        - 2代: 在一次以上的垃圾回收后任然未被回收的对象
    - 低一代的GC触发，移动到高一代后，未必会触发高一代的GC，只有高一代的内存不足时才会触发高一代的GC
    - 不同代的自动GC频率是可以设置的，一般0:1:2的频率为100：10：1

- 操作图解释分代的过程:

![c2946fc2ec499605030049306eef61c0.png](img/4892_1.png)

![93715a475185a503e7beecd808e743e8.png](img/4894_1.png)


-  非托管对象的回收
    - 对于非托管对象的管理，不受CLR的自动内存管理操作，这部分需要借鉴CLR的自动管理或者手动执行内存回收，这就是两种非托管对象的管理方式: Finalize和Dispose
    - 非托管资源: 原始的操作系统文件句柄，原始的非托管数据库连接，非托管内存或资源

- Finalize
    - System.Object定义了Finalize()虚方法，不能用override重写，其写法类似c++的析构函数:
``` C#
class Finalization{
    ~Finalization()
    {
        //这里的代码会进入Finalize方法
        Console.WriteLine("Enter Finalize()");
    }
}
```

- 转换的IL:

    ![6e65ed60af2d7c62490f0dc834fbf47f.png](img/4896_1.png)
    - 基类方法放入到Finally中，其本质还是交给GC进行处理，只是其执行的时间不确定，是在GC完后在某个时间点触发执行Finalize方法，使用这个方法的唯一好处就是: 非托管资源是必然会被释放的。



- IDisposable
    - 继承了该接口，则需要实现Disposable接口，需要手动调用，这就确保了回收的及时性，对应的问题是如果不显示调用Dispose方法，则这部分非托管资源是不会被回收的。
    - c#中的using关键字，转换成IL语句，就是内部实现了IDispoable方法，最终的try/finally中，会在finally中调用dispose方法。

- Unity中的C# GC
    - 目前unity2018.4还是 Boehm–Demers–Weiser garbage collector， unity2019.1 中已经开始引入: Incremental Garbage Collection增量式垃圾回收功能,
    - 相关链接: https://www.gamefromscratch.com/post/2018/11/27/unity-add-incremental-garbage-collection-in-20191.aspx



## **Unity GC（垃圾回收）**

参考链接：

[https://www.bilibili.com/video/BV1BJ4m1u7h4/?spm_id_from=333.1387.favlist.content.click&vd_source=814330d3527237342cf943b532e345a5](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1BJ4m1u7h4/%3Fspm_id_from%3D333.1387.favlist.content.click%26vd_source%3D814330d3527237342cf943b532e345a5)

[https://docs.unity3d.com/cn/2019.4/Manual/UnderstandingAutomaticMemoryManagement.html](https://link.zhihu.com/?target=https%3A//docs.unity3d.com/cn/2019.4/Manual/UnderstandingAutomaticMemoryManagement.html)

GC就是**定位和释放未使用内存的过程**，是一种自动内存管理机制，它会在程序运行时持续监控内存使用情况，自动识别并释放不再被程序使用的对象所占用的内存空间，从而防止内存泄漏并简化开发者的内存管理工作

**针对内存区域：**内存中的堆区域，在堆区域分配内存再通过指针访问的类型称为引用类型，引用类型包括：对象、字符串、数组

**为什么使用GC：**

1）C/C++不支持GC，需要手动管理内存，用new()申请内存delete()释放

2）手动管理内存经常会忘记释放申请的内存，导致内存泄漏，更严重可能会出现内存溢出

3）使用GC减少了编码工作，也大大降低了内存泄漏的可能性

**UnityGC的执行流程：**

1）遍历内存中的所有对象，检查每个对象是否被其他对象引用

2）将没有被其他对象引用的对象标记为可释放

3）释放所有被标记的对象

### **核心机制**

**分代回收机制（Generational GC）：**

将堆内存分为三代，基于对象存活时间的不同来分级回收：

- 第0代

- - 存储新创建的短期对象（如临时对象、每帧生成的例子特效）
  - 回收频率最高：第0代堆满时立即触发
  - 存活对象晋升：未被回收的对象会被晋升到第1代

- 第1代

- - 存储从第0代晋升的中期对象（如存活较久的游戏实体）
  - 回收频率中等：当第0代回收后内存仍不足时触发（连带回收第0代）

- 第2代

- - 存储长期存活的大对象（如全局管理器、静态资源）
  - 回收成本最高：仅当第0/1代回收仍不足时触发全堆回收

**增量式GC（Incremental GC）**

- 将单次GC操作分摊到多帧执行，减少卡顿
- 适用于开发世界、大型游戏避免GC导致的帧率骤降

### **触发时机**

Unity GC的触发是由内存分配需求驱动的

**(1) 自动触发**

- 第0代堆满：立即触发第0代GC
- 第1/2代堆满：逐级触发更高代回收
- 低内存状态：系统内存紧张时可能提前触发GC

**(2) 手动触发**

- `System.GC.Collect()`：强制触发全堆回收
- 使用场景：场景切换、加载大型资源

**(3) 特殊触发点**

- 卸载未用资源：`Resources.UnloadUnuseAssets()`
- 卸载AssetBundle：`AssetBundle.Unload(true)`

### **问题**

每当Unity需要执行GC时，它会停止运行程序代码并且在GC完成后才恢复运行，此中断可能会导致游戏延迟，持续时间取决于回收内存的大小以及游戏运行的平台，这带来了帧率不稳的问题。

下面时一些导致GC使用不当的代码

1）高频字符串拼接

```csharp
void Update() {
    string text = "HP:" + hp + "/" + maxHp; // 每次拼接生成新字符串 → 第0代堆快速填满
}
```

2）未缓存组件引用

```csharp
void Update() {
    GetComponent<Rigidbody>().velocity = Vector3.forward; // 每次调用可能产生GC
}
```

3）滥用Instantiate/Destroy

```csharp
void Shoot() {
    var bullet = Instantiate(bulletPrefab); // 分配内存
    Destroy(bullet, 2f); // 产生GC垃圾
}
```

4）协程中频繁yield new对象

```csharp
IEnumerator Flash() {
    while (true) {
        yield return new WaitForSeconds(1f); // 每次new对象 → GC
    }
}
```

5）值类型装箱

```csharp
int score = 100;
object boxedScore = score; // 装箱 → 堆分配
```

### **优化**

**卡顿原因**：1）高频0代回收；2）耗时全队回收（2代回收）

**优化整体思路：**1）不new不GC（减少分配）；2）能复用不创建（对象池）；3）该出手时就出手（手动GC）

**（1）避免高频临时对象分配**

- 用`StringBuilder` 代替字符串拼接
- 缓存组件引用（只调用`GetComponent`一次）
- 避免在Update中`new`对象

**（2）使用对象池**

- 子弹/敌人/特效等高频创建对象
- 复用对象代替`Instantiate/Destroy`

```text
// 对象池伪代码
public class ObjectPool {
 private Queue<GameObject> _pool = new Queue<GameObject>();

 public GameObject Get() {
 return _pool.Count > 0 ? _pool.Dequeue() : Instantiate(prefab);
    }

 public void Return(GameObject obj) {
 obj.SetActive(false);
 _pool.Enqueue(obj);
    }
}
```

**（3）值类型处理（避免装箱）**

- 使用`List<int>`代替`ArrayList`
- 避免值类型转`Object`接口

```text
/ ❌ 装箱（GC警告）
int health = 100;
object boxed = health; 

// ✅ 无GC方案
List<int> healthList = new List<int>(); // 泛型集合
healthList.Add(health); 
```

**（4）手动GC**

- 切换场景时主动调用

```text
IEnumerator LoadLevel() {
 Resources.UnloadUnusedAssets();
 GC.Collect(); // 主动触发
 yield return null; // 等待GC完成
 SceneManager.LoadScene("Level2");
}
```

**性能监控：**可以使用Unity Profiler来查看想能，定位脚本发生问题的代码位置






# Lua

### Lua 元表

菜鸟教程:https://www.runoob.com/lua/lua-metatables.html

lua的元表以及多继承:https://www.jianshu.com/p/3eaa69a6d0a2


### Lua GC

**基本数据结构**
lua的基本数据结构: union + type
``` lua
typedef union Value{
    GCObject* gc;   //gc object
    void* p;       // light userdata
    int b;         // booleans
    lua_CFunction f; // light c functions
    lua_Integer i;   //integer number 5.1为double，5.3为long long 8个字节
    lua_Number n;   // double number 5.3 为double 8个字节
} Value;

struct lua_Value{
    Value value_;
    int tt_;
} TValue;
```
对于所有的需要被GC的对象，都会放在GCObject组成的链表中


**GC算法和流程**

1.双色标记清除算法
在Lua5.0中的GC，是一次性不可被打断的操作，执行的算法是Mark-and-sweep算法，在执行GC操作的时候，会设置2种颜色，黑色和白色，然后执行gc的流程，大体的伪代码流程如下:



``` c
每个新创建的对象为白色

//初始化阶段
遍历root链表中的对象，并将其加入到对象链表中    

//标记阶段   
当前对象链表中还有未被扫描的元素:    
    从中取出对象并将其标记为黑色   
    遍历这个对象关联的其他所有对象: 
        标记为黑色
        
//回收阶段
遍历所有对象:   
    如果为白色:   
        这些对象没有被引用，则执行回收
    否则: 
        这些对象仍然被引用，需要保留
```
整个过程是不能被打断的，这是为了避免一种情况：
如果可以被打断，在GC的过程中新创建一个对象
那么如果标记为白色，此时处于回收阶段，那么这个对象没有被扫描就会被回收；
如果标记为黑色，此时处于回收阶段，那么这个对象没有被扫描就会被保留
两种情况都不适合，所以只有让整个过程不可被打断，带来的问题就是造成gc的时候卡顿

**三色标记清除算法**
虽然是三色，本质是四色，颜色分为三种:
- 白色: 当前对象为待访问状态，表示对象还未被gc标记过，也就是对象创建的初始状态； 同理，如果在gc完成后，仍然为白色，则说明当前对象没有被引用，则可以被清除回收
- 灰色: 当前对象为待扫描状态，当前对象已经被扫描过，但是其引用的其他对象没有被扫描
- 黑色: 当前对象已经扫描过，并且其引用的其他对象也被扫描过

其流程伪代码:
``` c
每个新创建的对象为白色

//初始化阶段   
遍历root阶段中引用的对象，从白色设置为灰色，并放入到灰色节点列表中   

//标记阶段    
当灰色链表中还有未被扫描的元素:    
    从中去除一个对象并将其标记为黑色   
    遍历这个对象关联的其他所有对象:   
        如果是白色:
            标记为灰色，并加入灰色链表中   
            
//回收阶段  
遍历所有对象:   
    如果为白色: 
        这些对象没有被引用，需要被回收
    否则:
        重新加入对象链表中等待下次gc   
整个标记过程是可以被打断的，被打断后回来只需要接着执行标记过程即可，回收阶段是不可被打断的。
```
如何解决在标记阶段之后创建的对象为白色的问题?
分裂白色为两种白色，一种为当前白色 currentwhite， 一种为非当前白色 otherwhite，新创建的对象都为otherwhite，则在执行回收的时候，如果为otherwhite则不执行回收操作，等待下次gc的时候，会执行白色的轮换，则新创建的对象会进入下一轮gc。

**lua gc的一些关键点**
1.初始化阶段的操作原理
以前我一直理解这个root就是将gcobject的链表进行转换到灰色链表中，其实并不是，而是去对当前虚拟机中的mainthread表, G表， registry表进行操作，其函数为:
``` c
static void markroot(lua_State * L)
{
    global_State *g = G(L);
    g->gray = NULL;
    g->grayagain = NULL;
    g->weak = NULL;
    //标记几个入口
    markobject(g, g->mainthread);
    markvalue(g, gt(g->mainthread));
    markvalue(g, registry(L));
    markmt(g);
    g->gcstate = GCSpropagte;
}
```
markobject/markvalue都是将对象从白色标记为灰色，所以这里面还有效的数据，就会最终进行扫描标记，如果最终不是白色，则会被保留，而执行回收操作的时候，是对gclist进行操作的，只要是currentwhite，那么就是可以被回收的。

2.对于中途创建的对象的颜色处理
这儿会分为两种，前向操作和后退操作:
- 前向操作: 新创建对象为白色，被一个黑色对象引用，则将当前新创建对象标记为灰色
- 后退操作: 新创建对象为白色，被黑色对象引用，该黑色对象退回到灰色，塞入到grayagain表中，后续一次性扫描处理

对大部分数据，都是前向操作，对于table类型数据，则如果其新创建对象，该table会回退到灰色塞入到grayagain表中。
本质没区别，主要是table属于频繁操作的对象，如果反复将table中新创建的对象都设置成灰色，则灰色链表会容易变得很大，所以为了提高性能，就将table塞入到grayagain表中，后续一次性处理即可。



### Lua pairs和ipairs的区别
lua中pairs和ipairs的区别:https://blog.csdn.net/Memoryuuu/article/details/85067701





# UGUI 

### **底层原理**

参考链接：[https://www.bilibili.com/video/BV17W4y1d7dY?spm_id_from=333.788.player.switch&vd_source=814330d3527237342cf943b532e345a5&p=4](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV17W4y1d7dY%3Fspm_id_from%3D333.788.player.switch%26vd_source%3D814330d3527237342cf943b532e345a5%26p%3D4)

（关于这方面的理解仍需加强）

UGUI的作用主要在于两方面：1）显示 2）交互

显示，抽象的来说就是：我们在屏幕中看到的UI的图形和布局；包括：1）图形的渲染，从3维到2维再到显示在屏幕上 2）UI元素控件布局，尺寸调整

交互，抽象的说就是：收到一件事情，让谁去干这件事，怎么干这件事；包括：1）输入 2）射线检测 3）控件事件交互

显示和交互一共包含的五个步骤，就是我们UGUI的核心类继承关系图，如下图，分别有五个模块：

1）输入模块BaseInputModule；2）射线检测模块BaseRayCaster；3）交互模块Selectable；4）布局模块LayoutGroup；5）图形模块Graphic

![img](https://pic1.zhimg.com/v2-7dbc51caf6d46c6f561195da869046b6_1440w.jpg)

仅仅有了UGUI核心的五个类模块还不行，我们需要让他们修调运作。在场景中创建Canvas时，还会自动创建一个[EventSystem](https://zhida.zhihu.com/search?content_id=256634224&content_type=Article&match_order=1&q=EventSystem&zhida_source=entity)，即我们创建UI时会有两个大的**实体**：Canvas和EventSystem；还记得刚才说的UGUI的两个大作用1）显示 2）交互，实际上EventSystem就负责管理 交互，Canvas和CanvasUpdateRegistry（一个静态服务类）就负责 显示；以**EventySystem**、**Canvas**、**CanvasUpdateRegitry**三者为核心，组织调度了UGUI的五个类模块，使其协同运作，组成了UGUI显示和交互的循环往复，这五个模块的顺序如下

![img](https://pic2.zhimg.com/v2-fcfaa4a8de4af9f2a4e4b392a7699967_1440w.jpg)

我们具体来说一说三个核心EventSystem、Canvas、CanvasUpdateRegistry

**EventSystem**

EventSystem是一个实体，负责管理UI的交互，作用包括：1）输入处理，将输入处理转换作为逻辑事件；2）射线检测，通过GraphicRaycaster确定命中的UI元素；3）状态管理，控制Seclectable的交互状态（如按钮按下或禁用状态）；每个场景只需要一个EventSystem实体即可

**CanvasUpdateRegistry**

CanvasUpdateRegistry是一个静态状态类，负责UI的更新，作用包括：1）脏标记管理，记录需要更新的UI元素；2）批量更新，在帧末统一处理所有更新请求；3）优先级控制，确保计算布局再更新图形

**Canvas**

Canvas是一个实体，是UI元素的物理承载和渲染终端，作用包括：1）渲染空间定义，决定UI显示在屏幕空间/世界空间；2）合批绘制，将相同材质的UI在同一批绘制；3）渲染控制，通过CanvasRender将网格数据提交给GPU

以这三者为核心，上图流程便可概括为：交互 -> 更新 -> 渲染，具体的代码执行流程如下

```text
Unity主循环
├─ EventSystem.Update()                          # 交互事件处理入口
│   ├─ StandaloneInputModule.Process()          // 输入模块（阶段1）
│   │   ├─ ProcessMouseEvent()                  → 生成PointerEventData
│   │   │   ├─ GetMousePointerEventData()       // 获取鼠标状态
│   │   │   └─ ExecuteEvents.Execute()          // 触发事件回调
│   │   │
│   │   └─ ProcessTouchEvent()                  → 处理触摸输入
│   │       ├─ GetTouchPointerEventData()       // 转换触摸数据
│   │       └─ ProcessMove/Press/Drag()         // 处理触摸阶段
│   │
│   └─ GraphicRaycaster.Raycast()               // 射线检测
│       ├─ 遍历所有raycastTarget=true的UI元素
│       └─ 返回按depth排序的命中列表
│
├─ CanvasUpdateRegistry.BeginFrame()            # 更新调度入口
│   ├─ PerformUpdate()                          // 关键更新入口（阶段2-3）
│   │   ├─ 布局阶段（阶段2）
│   │   │   ├─ LayoutRebuilder.Rebuild()        
│   │   │   │   ├─ CalculateLayoutInput()       // 水平/垂直计算
│   │   │   │   │   ├─ minWidth/preferredWidth计算
│   │   │   │   │   └─ 子元素间距处理
│   │   │   │   │
│   │   │   │   └─ SetLayout()                  // 应用布局
│   │   │   │       ├─ SetChildAlongAxis()      // 定位子元素
│   │   │   │       └─ 处理Padding/Spacing
│   │   │   │
│   │   │   └─ ContentSizeFitter.OnRectTransformDimensionsChange()
│   │   │       └─ 自适应尺寸调整
│   │   │
│   │   ├─ 图形阶段（阶段3）
│   │   │   ├─ Graphic.Rebuild()               
│   │   │   │   ├─ OnPopulateMesh()             // 生成顶点数据
│   │   │   │   │   ├─ Text生成文字网格
│   │   │   │   │   └─ Image生成UV坐标
│   │   │   │   │
│   │   │   │   └─ UpdateGeometry()             // 提交GPU
│   │   │   │       ├─ canvasRenderer.SetMesh()
│   │   │   │       └─ 材质/纹理绑定
│   │   │   │
│   │   │   └─ MaskableGraphic.UpdateMaterial() // 遮罩处理
│   │   │       └─ 处理Stencil缓冲
│   │   │
│   │   └─ 脏数据清理
│   │       ├─ 清空布局重建队列
│   │       └─ 清空图形重建队列
│   │
│   └─ Canvas.SendWillRenderCanvases()          // 预渲染回调
│
└─ Rendering管线                                # 最终输出（阶段4）
    ├─ CanvasRenderer.OnRender()                // 合批绘制
    │   ├─ 动态合批处理
    │   │   ├─ 合并相同材质的UI元素
    │   │   └─ 生成最优DrawCall
    │   │
    │   └─ 提交GPU指令
    │       ├─ 设置渲染状态
    │       └─ 调用GL/DirectX API
    │
    └─ 根据RenderMode处理输出
        ├─ ScreenSpace-Overlay → 直接绘制到屏幕
        ├─ ScreenSpace-Camera → 通过指定相机渲染
        └─ WorldSpace → 3D空间渲染
```

### **Canvas渲染模式**

Canvas主要有三种渲染模式：

1）Screen Space -Overlay(屏幕空间-覆盖)：

- UI直接覆盖在屏幕最上层，无视3D场景
- 无需摄像机，性能最高，适合纯2D UI
- UI元素自动适配屏幕分辨率

2）Screen Space -Camera(屏幕空间-摄像机)

- UI通过指定摄像机渲染，可以结合3D场景
- UI元素受摄像机参数影响，但始终面向摄像机
- 支持UI与3D物体的交互（如遮挡）

3）World Space(世界空间)

- UI作为3D场景中的物体，可自由旋转、缩放
- 需手动设置RectTransform的位置和大小
- 性能较低，适合少量动态UI

### **UGUI打包图**

1）启用Sprite Packer

Edit -> Project Settings -> Editor -> Sprite Packer Mode -> Always Enabled

2）创建Sprite Atlas文件

project文件夹 -> Create -> 2D -> Atlas文件

3）添加精灵到图集

选中Atlas文件 -> Inspector -> Object for Packing中拖入精灵或文件夹

4）配置参数

- **Padding**: 2-4像素（防边缘渗色）
- **Compression**: 移动端选`ASTC 4x4`，PC选`BC7`
- **Allow Rotation**: 关闭（避免UI错位）
- **Include in Build**: 勾选（否则运行时失效）

5）代码动态加载

```csharp
public SpriteAtlas atlas;
Image image;
void Start() {
    image.sprite = atlas.GetSprite("icon_name");
}
```

### **Image和RawImage的区别**

在Unity UGUI中，**Image** 和 **RawImage** 都是用于显示2D图像的基础组件，但它们在功能、性能和使用场景上有显著区别。以下是详细对比：

| 特性         | Image                              | RawImage                          |
| ------------ | ---------------------------------- | --------------------------------- |
| 适用纹理类型 | 仅支持Sprite（需导入为Sprite类型） | 支持任意Texture2D/RenderTexture等 |
| UV控制       | 不支持UV偏移/缩放                  | 支持动态调整UV（uvRect参数）      |
| 性能         | 更高（针对UI优化）                 | 较低（灵活性强但开销大）          |
| 材质支持     | 默认使用UI材质，可自定义           | 需手动指定材质                    |
| 多平台兼容性 | 自动适配Sprite的压缩格式           | 需手动处理纹理压缩                |

## **摄像机**

### **两种模式**

Unity的摄像机分为两种模式：1）正交模式（Orthographic）；2）透视模式（Perspective）

**正交模式：**无透视变形，物体大小不受距离影响（平行投影）；通过`Size`参数控制显示范围

**透视模式：**模拟人眼视角，具有近大远小的3D效果；通过`Field Of View(FOV)`控制视野范围

如何切换两种模式：选中Camera -> Inspector面板 -> 勾选/取消`Orthographic`属性

### **成像原理**

首先，来看一看渲染的基本流程：

1）应用阶段（CPU）：准备要渲染的物体，提出看不见的部分，告诉GPU画什么

2）几何阶段（顶点处理）：把3D模型的顶点转换成摄像机视角，并投影到2D屏幕

3）光栅化阶段：把三角形拆解成一个个像素点（Fragment），准备上色

4）像素处理阶段：计算每个像素的颜色（纹理+关照），并解决遮挡问题（深度测试）

5）输出阶段：混合半透明效果，最终输出到屏幕或渲染纹理

正交和透视模式的区别在于结合阶段的投影变换不同：

正交：使用正交矩阵进行投影变换，将视锥体的顶点坐标进行线性变换等比压缩到立方体中

透视：使用透视矩阵进行投影变换，将视锥体的顶点坐标进行非线性变换扭曲到立方体中

## **DrawCall**

Draw Call是CPU向GPU发送的一次绘制指令，要求其渲染一个或多个物体（如网格+材质），每次调用都会产生通信开销，直接影响渲染性能

### **静态合批、动态合批**

**静态合批：**将多个静态（不移动/旋转/缩放）的物体合并为一个大网格，一次性提交给GPU渲染

**动态合批：**Unit运行时自动将满足条件的小网格合并为一个Draw Call（每帧动态处理）

| 特性     | 静态合批                  | 动态合批                     |
| -------- | ------------------------- | ---------------------------- |
| 处理阶段 | 运行前/场景加载时         | 运行时每帧处理               |
| 内存占用 | 高（存储合并后的网格）    | 低（临时合并数据）           |
| 适用对象 | 静态物体                  | 动态小网格物体               |
| 材质要求 | 可不同材质                | 必须相同材质                 |
| 性能影响 | 减少Draw Call，但增加内存 | 减少Draw Call，但增加CPU计算 |

### **Draw Call、Batch、SetPass Call区别**

| 概念         | 触发条件           | 优化目标      | 性能影响        |
| ------------ | ------------------ | ------------- | --------------- |
| Draw Call    | CPU提交渲染指令    | 减少通信次数  | CPU→GPU带宽压力 |
| Batch        | 合并相同材质的物体 | 减少Draw Call | 间接降低CPU开销 |
| SetPass Call | GPU切换材质参数    | 减少状态切换  | GPU渲染效率     |





# UnityEngine

## **AB包**

#### **基本概念**

**是什么：** AB包是Unity的资源动态加载技术，将游戏资源（场景、模型、贴图等）打包成独立文件，运行时按需记载，实现热更新、减小安装包体积

**为什么：**

1）安装包过大：传统打包需要把所有资源塞进安装包，体积过大；AB包只需放核心资源，非必要资源后续下载

2）无法热更新：传统更新修复BUG需重新上交应用商店审核；AB包更新直接替换服务器上的AB包，玩家重启游戏后立即生效

3）内存浪费：传统加载`Resources.load`一次性加载所有资源，内存占用高；AB包按需加载/卸载，动态管理内存

#### **用法**

1. 标记资源（设置AB包名称）：选中资源，Inspector窗口底部设置AssetBundle名称
2. 打包AB包（Build）：注意参数

- `BuildAssetBundleOptions`（压缩方式）：1）`None`（无压缩加载快，但体积大）；2）`LZMA`（高压缩，需解压，适合下载）；3）`LZ4`（快速加载，适合运行时）
- `BuildTarget`（目标平台）：选择匹配的目标平台（如Android、iOS、StandaloneWindows）
- 加载AB包（运行时）：可以从本地（StreamingAssets）或 服务器（热更新）加载

- - 从本地加载（适用于初始资源）

```text
using UnityEngine;

public class LoadABFromLocal : MonoBehaviour {
 void Start() {
 string path = Path.Combine(Application.streamingAssetsPath, "AssetBundles/characters.unity3d");
 
 // 同步加载
 AssetBundle ab = AssetBundle.LoadFromFile(path);
 GameObject playerPrefab = ab.LoadAsset<GameObject>("Player"); // 加载预制体
 Instantiate(playerPrefab);

 // 异步加载（推荐，避免卡顿）
 StartCoroutine(LoadABAsync(path));
    }

 IEnumerator LoadABAsync(string path) {
 AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);
 yield return request;

 AssetBundle ab = request.assetBundle;
 GameObject playerPrefab = ab.LoadAsset<GameObject>("Player");
 Instantiate(playerPrefab);
    }
}
```

- - 从服务器上下载（热更新）

```text
using UnityEngine;
using UnityEngine.Networking;

public class LoadABFromWeb : MonoBehaviour {
 void Start() {
 StartCoroutine(DownloadAB("http://yourserver.com/AssetBundles/weapons.unity3d"));
    }

 IEnumerator DownloadAB(string url) {
 UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(url);
 yield return request.SendWebRequest();

 if (request.result == UnityWebRequest.Result.Success) {
 AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request);
 GameObject weaponPrefab = ab.LoadAsset<GameObject>("Sword");
 Instantiate(weaponPrefab);
        } else {
 Debug.LogError("下载失败: " + request.error);
        }
    }
}
```

4. 卸载AB包（释放内存）

```text
// 卸载单个AB包（false = 只卸载AB包，不销毁已加载的资源）
ab.Unload(false); 

// 彻底卸载（true = 卸载AB包 + 销毁所有加载的资源，慎用！）
ab.Unload(true); 

// 强制清理未使用的资源（类似GC）
Resources.UnloadUnusedAssets();
```

#### **依赖**

**是什么：** AB包依赖指的是多个资源包的引用关系。比如，角色模型（`character.ab`）使用了公共材质（`material.ab`），那么`character.ab`就依赖`material.ab`，如果不先加载材质包，角色就会变成“紫色丢失状态”。

**依赖管理的核心方法：**

Unity打包时会自动生成一个总清单文件（AssetBundleManifest），记录所有AB包的依赖关系，加载时需要：

1）先加载这个清单

2）通过`GetAllDependencies()`获取依赖列表

3）递归加载所有依赖的AB包

4）最后加载AB包

#### **Addressable**

**是什么：** Addressable（可寻址资源系统）是Unity官方推出的**资源管理框架**，基于AssetBundle但更高级，主要解决：

1）自动处理依赖关系，不同手动加载依赖的AB包

2）简化热更新流程，内置版本对比和下载

3）内存管理自动化，自动卸载不用的资源

4）支持异步加载，不卡主线程

**核心思想：**给每个资源分配唯一地址，通过地址加载资源，无需关心底层是AB包还是本地资源



## **Unity MonoBehaviour**

参考链接：[https://blog.csdn.net/woodengm/article/details/126472371](https://link.zhihu.com/?target=https%3A//blog.csdn.net/woodengm/article/details/126472371)

假如把GameObject比作机器人，MonoBehaviour就是机器人的控制芯片。MonoBehaviour是Unity的核心类，所有脚本都必须继承于它，才能成为GameObject的挂载组件，并于Unity引擎进行交互。

![img](https://picx.zhimg.com/v2-deb34b454666aeb7d11befed87a98f21_1440w.jpg)

**继承关系：**这是一张Unity的类的继承关系图，首先是C#的所有引用类型的基类System.Object，继承它的子类是Unity中所有引用类型的基类UnityEngine.Object；继承UnityEngine.Object的子类有个组件类基类Component，他代表所有附加在GameObject上的对象；在Component的基础上，添加了enable（启用或禁用）的能力，这就是继承自Component的子类Behaviour，有很多继承自Component的子类比如Animator、Light、Camera等，它们可以启用或禁用，这些子类当中有一个类就是MonoBehavior

MonoBehavior的作用体现在三个方面：1）生命周期管理；2）组件化架构；3）丰富的引擎继承功能

**生命周期管理：**提供Awake、Start、Update等回调函数，是我们可以精确控制脚本在不同阶段的初始化、更新和销毁逻辑

**组件化架构：**每个MonoBehaviour脚本都是一个独立的功能模块，可以灵活地挂载到GameObject上，这是一种遵循单一职责原则的设计，使得游戏对象的功能组合更加灵活

**丰富的引擎继承功能：**提够了提供了系统协程、物理回调、消息传递能功能

## **Unity 生命周期管理**

游戏对象的生命周期包括四个阶段：1）初始化；2）游戏循环；3）非活跃期；4）销毁

初始化：Awake, OnEnable, Start

**Awake()**

- **对象**刚被**创建**时立即调用（即使脚本未启用）
- 适合初始化变量、获取组件引用

**OnEnable()**

- 当**脚本或对象**被**激活**时调用
- 适合注册事件监听、恢复游戏状态

**Start()**

- 在第一帧Update之前调用（仅一次）
- 适合其他**组件完成初始化后**的设置

游戏循环：[FixedUpdate](https://zhida.zhihu.com/search?content_id=256634224&content_type=Article&match_order=1&q=FixedUpdate&zhida_source=entity), Update, [LateUpdate](https://zhida.zhihu.com/search?content_id=256634224&content_type=Article&match_order=1&q=LateUpdate&zhida_source=entity)

**FixedUpdate**

- 固定时间间隔调用
- 适合物理计算

**Update()**

- 每帧调用一次（不固定时间间隔）
- 适合游戏逻辑、输入处理

**LateUpdate()**

- 在所有Update之后调用
- 适合摄像机跟随等需要最后调整的逻辑

非活跃期：[OnDisable](https://zhida.zhihu.com/search?content_id=256634224&content_type=Article&match_order=1&q=OnDisable&zhida_source=entity)

**OnDisable()**

- 脚本/对象被禁用时调用
- 适合取消事件监听、保存临时状态

销毁：OnDestroy，[OnApplicationQuit](https://zhida.zhihu.com/search?content_id=256634224&content_type=Article&match_order=1&q=OnApplicationQuit&zhida_source=entity)

**OnDestroy()**

- 对象被销毁前调用
- 适合释放资源、清理引用

**OnApplicationQuit()**

- 游戏退出时所有对象都会收到
- 适合保存游戏最终状态

## **Unity 协程**

协程是**运行在单线程内的可暂停函数**，通过`yield`指令在代码中插入多个断点，让执行流可以在这个断点暂停和恢复。

其核心特点包括：

1）单线程执行：所有协程在调用它的主线程上执行

2）主动让出：通过`yield`指令主动转让控制权

3）极低开销：上下文切换只需保存少量寄存器的值

4）无并行性：多个协程交替执行，而不是同时运行

### **进程、线程和协程**

进程是操作系统分配和调度资源的基本单位，拥有独立内存空间，切换开销大；线程是进程中的执行流，共享进程资源，由操作系统调度，能实现并行但需处理线程同步；协程是运行在单线程内的可暂停函数，通过`yield`指令实现交替执行，无并行能力但切换成本极低；

打个比方：进程是单个公司，线程是公司内多个部门同时工作，协程就是同部门多个员工轮岗；资源隔离性递减，切换成本递减

### **为什么需要协程**

协程时处理时序逻辑的利器，通过分段执行的机制，解决了以下核心痛点：

1）时序控制：用同步代码实现流程，避免回调地狱

2）性能优化：通过`yield return null` 或 `WaitForSecond` 实现分帧操作，将密集计算分摊到多帧执行，避免单帧卡顿

3）引擎整合：原生支持Unity的生命周期，直接调用UnityAPI，无需考虑多线程问题

### **实现原理**

Unity协程的实现包括两个部分：1）编译器生成状态机；2）Unity引擎的协程调度

**编译器生成状态机**

我们编写一个协程代码如下时

```csharp
IEnumerator MyCoroutine() {
    Debug.Log("A");
    yield return new WaitForSeconds(1);
    Debug.Log("B");
}
```

C#会将其编译为如下的状态机类，所谓状态机类时编译后的隐藏类，通过状态变量和分段执行实现协程的暂停/恢复功能，`MoveNext()`中的逻辑：1）执行当前代码语句；2）执行`yield`指令后的代码；3）变量更新；代码如下

```csharp
class <MyCoroutine> : IEnumerator {
    private int _state; //状态变量
    private object _current; //yield指令暂停的分割点
    
    bool MoveNext() {
        switch(_state) {
            case 0: // 对应yield之前的代码
                Debug.Log("A");
                _current = new WaitForSeconds(1);
                _state = 1;
                return true;
            case 1: // 对应第一个yield之后的代码
                Debug.Log("B");
                _state = -1; // 结束标记
                return false;
        }
        return false;
    }
}
```

**Unity引擎的协程调度**

Unity引擎底层维护了一个活跃协程列表，1)每帧末尾检查所有活跃协程；2）通过`MoveNext()`推进协程到下一个`yield`点；3）自动移除已完成的协程，伪代码逻辑如下

```csharp
class CoroutineScheduler {
    List<IEnumerator> _activeCoroutines;
    
    void Update() {
        for(int i=0; i<_activeCoroutines.Count; i++) {
            var coroutine = _activeCoroutines[i];
            // 检查yield条件是否满足
            if(IsYieldConditionMet(coroutine.Current)) { 
                if(!coroutine.MoveNext()) { // 推进状态机
                    _activeCoroutines.RemoveAt(i--);
                }
            }
        }
    }
    
    bool IsYieldConditionMet(object yieldInstruction) {
        if(yieldInstruction == null) return true; // yield return null
        if(yieldInstruction is WaitForSeconds wfs) 
            return Time.time >= wfs._resumeTime;
        // 其他yield类型判断...
    }
}
```

## **Unity Delegate（委托）**

参考链接：[https://www.bilibili.com/video/BV1vgpreoE2p/?spm_id_from=333.1387.favlist.content.click&vd_source=814330d3527237342cf943b532e345a5](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1vgpreoE2p/%3Fspm_id_from%3D333.1387.favlist.content.click%26vd_source%3D814330d3527237342cf943b532e345a5)

![img](https://pic1.zhimg.com/v2-6d6bbb43022f6d8f28a019991af20a7e_1440w.jpg)

### **基本概念**

**是什么：**delegate是C#中类型安全的函数指针，允许将方法作为参数传递或动态调用，本质是对方法的引用和封装。

**为什么：**委托的核心价值是将方法作为参数传递，实现灵活的回调机制，从而解耦代码、增强扩展性；本质上就是将“做什么”和“谁来做”分离，通过方法抽象实现：1）解耦，模块间无需相互引用；2）扩展性，新增功能无需修改原有代码；3）复用性，统一委托可绑定不同方法

### **用法**

### **1 基本用法**

定义委托类型

```csharp
// 声明委托类型（方法签名约束）
public delegate void MyDelegate(int num);
public delegate string StringProcessor(string input);
```

生命委托变量并绑定方法

```csharp
MyDelegate myDelegate;

void Start() {
    // 绑定方法
    myDelegate = PrintNumber;       // 直接绑定
    myDelegate += (x) => {         // 添加Lambda表达式
        Debug.Log("Lambda: " + x); 
    };
}

void PrintNumber(int num) {
    Debug.Log("Number: " + num);
}

void Update() {
    if (Input.GetKeyDown(KeyCode.Space)) {
        myDelegate?.Invoke(42); // 安全调用
    }
}
```

### **2 内置委托类型**

**`Action`：无返回值**

```csharp
Action<int, string> action = (num, text) => {
    Debug.Log($"{text}: {num}");
};
action(10, "Score");
```

**`Func`：带返回值**

```csharp
Func<int, int, string> func = (a, b) => {
    return (a + b).ToString();
};
string result = func(3, 5); // "8"
```

### **3 事件封装**

委托的安全封装，使用`event`关键字，限制外部仅能`+=`或`-=`

```csharp
public class Player : MonoBehaviour {
    public event Action<int> OnHealthChanged; // 事件

    private int _health = 100;
    
    void TakeDamage(int damage) {
        _health -= damage;
        OnHealthChanged?.Invoke(_health); // 触发事件
    }
}

// 其他脚本订阅
public class UIHealthBar : MonoBehaviour {
    void Start() {
        FindObjectOfType<Player>().OnHealthChanged += UpdateUI;
    }

    void UpdateUI(int health) {
        Debug.Log($"Health: {health}");
    }
}
```

## **碰撞检测**

Unity的碰撞检测（Collision Detection）是物理系统的核心功能，用于判断游戏对象之间的接触或交叉，并触发相应事件。

### **Collider、Rigidoby、Trigger**

Collider决定碰撞形状 ，在此基础上Rigdbody和Trigger二选一

- Rigidbody决定物理引擎开关，是需要添加的一个组件，为物体添加质量、重力等物理属性，使其受物理引擎驱动（移动、旋转、受力）
- Trigger决定事件检测开关，在Collider中勾选，关闭物理碰撞，仅保留事件检测

### **碰撞事件与触发事件**

碰撞事件（物理响应）：双方均有`Collider`+至少一方有`Rigidbody`

触发事件（无物理响应）：双方均有`Collider`+至少一方勾选`Is Trgger`

### **碰撞检测的实现**

1）基础代码

```csharp
public class Bullet : MonoBehaviour {
    void OnCollisionEnter(Collision collision) {
        if (collision.gameObject.CompareTag("Enemy")) {
            Destroy(collision.gameObject); // 击中敌人
        }
    }
}
```

2）射线检测（Raycast）

```csharp
RaycastHit hit;
if (Physics.Raycast(transform.position, transform.forward, out hit, 10f)) {
    Debug.Log("击中：" + hit.collider.name);
}
```

3）形状检测（Overlap）

```csharp
Collider[] hits = Physics.OverlapSphere(transform.position, 5f);
foreach (var hit in hits) {
    // 处理检测结果
}
```



## 总结

### Unity 协程和线程,进程的区别



- 其实很简单，首先需要理解进程和线程是怎么一回事：进程是Windows系统中的一个基本概念，他包含着运行一个程序所需要的基本资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。　　
- 进程和线程的区别通过以上，一目了然。　　
- 再谈谈线程和协程的区别。一般应用一个应用程序只使用线程这一“资源”。
- 需要明确，Unity只使用了一个线程，但是，我们需要”同时做很多事“，那Unity作为单线程，该如何去做，协程，就来了，协程是一种”伪线程“。 协同程序（coroutine）.,即协作式程序，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协成处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component。　　　　
- 同一时间只能执行某个协程，协程适合对某个任务进行分时处理。　　　　
- 控制代码在特定的时间执行。　　　　
- 协程不是线程，也不是异步执行，跟Update一样，在主线程中执行。　　　　
- 不用考虑同步和锁的问题。　　　　
- 协程是一个分部组件，遇到条件（yield return）会挂起,直到条件满足才会被唤起执行后面的语句。

### 本地坐标系 世界坐标系



- 世界坐标系：世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言，这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。
- 本地坐标系：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。
- 使用TransformPoint方法将本地坐标系转为世界坐标系

### Unity调整旋转



- 矩阵旋转：
  - 优点：旋转轴可以是任意向量
  - 缺点：旋转其实只需要知道一个向量+一个角度(共4个信息值)，但矩阵却用了16个元素(矩阵法消耗时间和内存)、
- 欧拉角旋转
  - 优点：容易理解，形象直观；表示更方便，只需要三个值(分别对应x、y、z轴的旋转角度)
  - 缺点：欧拉角这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同结果；欧拉角旋转会造成万向锁现象，这种现象的发生就是由于上述固定的坐标轴旋转顺序造成的。理论上，欧拉角旋转可以靠这种顺序让一个物体旋转到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合，就会发生万向锁现象，这时就会丢失一个方向上的旋转能力(两个旋转轴(环)重叠)，也就是说在这种状态下，我们无论怎么旋转(还是按照原先的旋转顺序)，都不可能得到某些想要的结果，除非打破原先的旋转顺序或者同时旋转三个轴。
  - 由于万向锁的存在，欧拉旋转无法实现球面平滑插值。
  - 万向锁的简单解决办法：构造一个不同的旋转层级顺序，但是万向锁总是会在某一个顺序发生，调整旋转顺序不是根本解决办法。（Unity使用的是Z-X-Y顺规，即旋转顺序为z轴、x轴、y轴，虽然某些情况下会出现万向锁，但是这种顺规出现万向锁的概率最小）
  - 万向锁解决办法：将欧拉角转换为四元数，对四元数进行Slerp插值，再将这一系列四元数转换为对应的欧拉角，然后作用于需要进行旋转的对象。这种做法缺点在于消耗内存，但是可以使物体任意旋转，灵活度高。
  - 使用欧拉旋转出现旋转路径偏移的根本原因：在万向锁情况下对欧拉角的插值不是线性的。(突变)
  - 静态欧拉角：其旋转轴使用的是静止不同的参考系。
  - 动态欧拉角：使用object本身的坐标系，因而会随着object旋转而旋转。(局部坐标系会随着对象的旋转而旋转)
- 四元数旋转
  - 优点：可以避免万向锁；只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；而且四元数旋转可以提供平滑插值。
  - 缺点：比欧拉旋转稍微复杂了一点，因为多了一个维度，理解更困难，不直观。





# 优化









# 图形学

### 渲染管线



- 定义: 显卡内部处理图像信号的并行处理单元,也称为渲染流水线
- 发生位置: CPU和GPU
- 渲染机理: 将图像所具备的图形信息(顶点、纹理、材质、摄像机位置等)经过一系列阶段的处理,最终- 转换为屏幕上的图像.
- 渲染流程:
  - 应用阶段
  - 几何阶段
  - 光栅化阶段

[![769eae9688803605f83baa9c3f2da1f9.png](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/4880_1.png)](https://github.com/Lafree317/Unity-InterviewQuestion/blob/master/img/4880_1.png)

- **应用阶段 Application Stage**
- 发生位置: CPU
- 阶段目标: 准备渲染所需的几何信息,即渲染图元(rendering primitives)
- 渲染数据:
  - 场景数据:如摄像机,视锥体,模型,光源..
  - 粗粒度剔除:即剔除不可见物体
  - 渲染状态:材质,纹理,Shader..
- 基本流程：
  - 加载数据到显存: 由于渲染管线的图形化处理基本位于GPU,所以渲染数据先从硬盘加载到RAM,再加载到显存以供GPU后续处理.
  - 设置渲染状态: 定义渲染图形的方式,例如使用顶点着色器或者片元着色器、材质、光源等.
  - 调用Draw Call: 由CPU发起的DrawCall指令给GPU,指向已经准备好的渲染图元
- Draw Call:
  - 本质:图像编程接口
  - 机理:CPU通过调用DrawCall向命令缓冲区(Command Buffer)的队列中添加渲染命令,而GPU则从已有的队列中读取渲染命令去执行
  - 优化:由于调用DrawCall即使得CPU准备大量渲染数据提交到缓冲队列,大量的DrawCall会使得CPU过载,因此尽量减少DrawCall的调用次数(如进行批处理,合并网格...)
- 几何阶段 Geometry Stage
  - 发生位置: GPU
  - 接收数据: 应用阶段所准备好的渲染图元的信息，也就是顶点数据（模型自身坐标系、顶点颜色、纹理UV等）
  - 阶段目标: 决定所需绘制图元的信息(绘制方法,绘制坐标)
  - 基本流程:
    - 顶点着色器(Vertex Shader):
      - 调用次数:每个顶点均调用一次
      - 工作:坐标转换(模型空间->齐次裁剪空间，也可说模型自身坐标->屏幕空间坐标。可人为干涉)和逐顶点光照(颜色计算)
    - 曲面细分着色器(Tessellation Shader):
      - 工作:细分图元
    - 几何着色器(Geometry Shader):
      - 工作:逐图元着色操作或是生成新的图元(减少CPU负担)
    - 裁剪(Clipping):
      - 工作:裁剪去不在摄像机视野内的顶点
    - 屏幕映射(Screen Mapping):
      - 工作:将图元的x和y坐标转换到屏幕坐标系(不对z坐标处理)
- 光栅化阶段 Rasterizer Stage
  - 发生位置: GPU
  - 接收数据: 几何阶段准备好的顶点信息
  - 阶段目标: 对几何阶段传递过来的屏幕空间的顶点信息进行处理,最终生成屏幕像素,渲染出图像
  - 基本流程:
    - 三角形设置(Triangle Setup):
      - 工作:根据几何阶段传递的数据(三角网络的顶点),计算三角网络每边的数据信息
    - 三角形遍历(Triangle Traversal):
      - 工作:根据三角形设置的结果,判断某个三角网格所覆盖的像素,并根据三个顶点的信息对整个覆盖区域进行 插值 ,生成一系列 片元(fragment) ，片元包含信息有:屏幕坐标、深度、法线、纹理...
    - 片元着色器(Fragment Shader): 又称像素着色器(Pixel Shader)
      - 调用次数:一个像素点调用一次
      - 工作:纹理采样,计算光照(阴影、明暗...)
    - 逐片元操作(Per-Fragment Operations):
      - 工作:模板测试->深度测试->混合->颜色缓冲区
    - 输出屏幕图像

### Unity DrawCall详解



https://blog.csdn.net/yu1368072332/article/details/85676537

### OpenGL渲染管线



绝大数OpenGL实现都有相似的操作顺序，一系列相关的处理阶段称为OpenGL渲染管线。图1-2显示了这些顺序，虽然并没有严格规定OpenGL必须采用这样的实现，但它提供了一个可靠的指南，可以预测OpenGL将以什么样的顺序来执行这些操作。 如果读者刚开始涉足三维图形编程，可能会对接下来的内容感到吃力。读者现在可以跳过这一部分内容，但在读完这本书的每一章时，都应该重温一下图1-2

[![311269b2263ba839611cb9d09a201d13.png](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/4882_1.png)](https://github.com/Lafree317/Unity-InterviewQuestion/blob/master/img/4882_1.png)

[![56ac48eac59de632671b924eef2bd350.jpeg](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/4884_1.jpg)](https://github.com/Lafree317/Unity-InterviewQuestion/blob/master/img/4884_1.jpg)

图1-2显示了Henry Ford在福特汽车公司采用的装配线方法，它也是OpenGL处理数据的方法。几何数据(顶点，直线和多边形)所经历的处理阶段包括求值和基于顶点的操作，而像素数据(像素，图像和位图)的处理过程侧有所不同。在最终的像素数据写入到帧缓冲区之前，这两种类型的数据都将经过相同的最终步骤(光棚化和基于片断的操作)。下面，我们更为详细地介绍OpenGL渲染管线的一些关键阶段。

1. 显示列表Display Lists 任何数据，不管它所描述的是几何图形还是像素，都可以保存在显示列表(display list)中，供当前或以后使用。当然，我们也可以不把数据保存在显示列表中，而是立即对数据进行处理，这种模式也称为立即模式(immediate mode)。当一个显示列表被执行时，被保存的数据就从显示列表中取出，就像在立即模式下直接由应用程序所发送的那样。
2. 求值器Evaluators 所有的几何图元最终都要通过顶点来描述。参数化曲线和表面最初可能是通过控制点以及成为基函数(Basic function)的多项式函数进行描述的。求职器提供了一种方法。根据控制点计算表示表面的顶点。这种方法是一种多项式映射，它可以根据控制点产生表面法线、纹理坐标、颜色以及空间坐标。
3. 基于顶点的操作Per-Vertex Operations 对于顶点数据，接下来的一个步骤就是"基于顶点的操作"，就是把顶点变换为图元。有些类型的顶点数据(例如空间坐标)是通过一个4x4 的浮点矩阵进行变换的。空间坐标从3D世界的一个位置投影到屏幕上的一个位置。如果启用了高级特性，这个阶段将更为忙碌。如果使用了纹理，这个阶段还将生成并变换纹理坐标。如果启用了光照，就需要综合变换后的顶点，表面法线，光源位置，材料属性以及其他光照信息进行光照计算，产生最终的颜色值。
4. 图元装配Primitive Assembly 图元装配的一个主要内容就是剪裁，它的任务是消除位于半空间(half-space)之外的那部分几何图元，而这个半空间是由一个平面所定义的。点剪裁就是简单地接受或拒绝顶点，直线或多边形剪裁则可能需要添加额外的顶点，具体取决于直线或多边形是如何进行剪裁的。在有些情况下，接下来需要执行一个称为透视除法(perspective division)的步骤。它使远处的物体看起来比近处的物体更小一些。接下来所进行的是视口(viewport)和深度(z 坐标)操作。如果启用了剔除功能(culling)并且该图元是个多边形，那么它就有可能被剔除测试所拒绝。取决于多边形模式，多边形可能被画成点的形式或者直线的形式。这个阶段所产生的结果就是完整的几何图元，也就是根据相关的颜色，深度(有时还有纹理坐标值以及和光棚化处理有关的一些指导信息)进行了变换和剪裁的顶点。
5. 像素操作Pixel Operations 在 OpenGL 的渲染管线中，和单路径的几何数据相比，像素数据所经历的流程有所不同。首先，来自系统内存的一个数组中的像素进行解包，从某种格式(像素的原始格式可能有多种)解包为适当数量的数据成分。接着，这些数据被缩放、偏移，并根据一副像素图进行处理。处理结果先进行截取，然后或者写入到纹理内存，或者发送到光棚化阶段。如果像素数据时从帧缓冲区读取的，就对他们执行像素转换操作(缩放、偏移、映射和截取)。然后，这些结果被包装为一种适当的格式，并返回到系统内存的一个数组中。OpenGL 有一种特殊的像素复制操作，可以把数据从帧缓冲区复制到帧缓冲区的其他位置或纹理内存中。这样，在数据写入到纹理内存或者写回到帧缓冲区之前，只需要进行一道像素转换就可以了。
6. 纹理装配Texture Assembly OpenGL 应用程序可以在几何物体上应用纹理图像，使它们看上去更为逼真。如果需要使用多幅纹理图像，把它们放在纹理对象中是一种明智的做法。这样，就可以很方便地在他们之间进行切换。有些 OpenGL 实现拥有一些特殊的资源，可以加速纹理的处理。这种资源可能是专用的，高性能的纹理内存。如果确实拥有这种内存，纹理对象可能会优先进行处理，以控制这种有限和宝贵的资源的使用。
7. 光棚化Rasterization 光棚化就是把几何数据和像素数据转换为片断(fragment)的过程。每个片断方块对应用于帧缓冲区中的一个像素。把顶点连接起来形成直线或者计算填充多边形的内部像素时，需要考虑直线和多边形的点画模式，直线的宽度，点的大小，着色模型以及用于支持抗锯齿处理的覆盖计算。每个片断方块都将具有各自的颜色和深度值。
8. 片断操作Fragment Operations 在数据实际存储到帧缓冲区之前， 将要执行一系列的操作。这些操作可能会修改甚至丢弃这些片断。所有这些操作都可以被启用或禁用。第一个可能执行的操作时纹理处理。在纹理内存中为每个片断生成一个纹理单元(texel，也就是纹理元素)，并应用到这个片断上。接着可能进行的是雾计算，然后是剪裁测试，alpha测试，模板测试和深度缓冲区测试(深度缓冲区用于消除被隐藏的表面)。如果一个片断无法通过一个启用的测试，它的连续处理过程可能会被中断。随后，将要执行的可能是混合，抖动，逻辑操作以及根据一个位掩码的屏蔽操作。最后，经过完整处理的片断就被绘制到适当的缓冲区，最终成为一个像素并到达它的最终栖息地。

### 光照模型



这里图片和知识点太多，就直接贴源地址了

1. [Unity Shader-学习-3.光照模型](https://www.jianshu.com/p/53c6710db1c5)
2. [Unity Shader-标准光照模型总结](https://blog.csdn.net/u010832643/article/details/90580897)
3. [Unity Shader-兰伯特光照模型与Diffuse Shader](https://blog.csdn.net/puppet_master/article/details/53074789)
4. [Unity Shader-Phong光照模型与Specularr](https://blog.csdn.net/puppet_master/article/details/53428885)

### 延迟渲染



我们知道，正向渲染(Forward Rendering)，或称正向着色(Forward Shading)，是渲染物体的一种 非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此 类推。 传统的正向渲染思路是，先进行着色，再进行深度测试。 其的主要缺点就是光照计算跟场景 复杂度和光源个数有很大关系。假设有 n 个物体， m 个光源，且每个每个物体受所有光源的 影响，那么复杂度就是 O(m*n)。

正向渲染简单直接，也很容易实现，但是同时它对程序性能的影响也很大，因为对每一个需 要渲染的物体，程序都要对每个光源下每一个需要渲染的片段进行迭代，如果旧的片段完全 被一些新的片段覆盖，最终无需显示出来，那么其着色计算花费的时间就完全浪费掉了。

可以将延迟渲染( Deferred Rendering)理解为先将所有物体都先绘制到屏幕空间的缓冲（即 Gbuffer， Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了 因计算被深度测试丢弃的⽚元的着色而产⽣的不必要的开销。 也就是说 延迟渲染基本思想 是，先执行深度测试，再进行着色计算，将本来在物空 间（三维空间）进行光照计算放到了 像空间（二维空间）进行处理。 对应于正向渲染 O(m*n)的 复杂度，经典的延迟渲染复杂度为 O(n+m)。

### shader 动态模糊



https://zhuanlan.zhihu.com/p/99487181

### 渲染相关优秀文章



基础渲染系列教程20篇（默认渲染管线） https://zhuanlan.zhihu.com/p/137429554

Unity Mesh基础系列4篇 https://zhuanlan.zhihu.com/p/188545267

[(1 封私信 / 26 条消息) 【游戏开发面经汇总】- 图形学基础篇 - 知乎](https://zhuanlan.zhihu.com/p/430541328)





# 算法

 

[(1 封私信 / 26 条消息) 【游戏开发面经汇总】- 算法编程篇 - 知乎](https://zhuanlan.zhihu.com/p/499548836)





# 网络

### TCP UDP



TCP/IP协议（一）网络基础知识 网络七层协议
https://www.cnblogs.com/wanghuaijun/p/10092930.html

- TCP(Transmission Control Protocol 传输控制协议)：是一种面向连接的、可靠的、基于字节流的传输层通信协议，使用三次握手协议建立连接、四次挥手断开连接。面向连接意味着两个使用TCP的应用(通常是一个客户端和一个服务器)在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用TCP。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，端口号拼接到IP地址即构成了套接字。
- UDP(User Datagram Protocol 用户数据报协议)：是OSI(Open System Interconnection 开放式系统互联)参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。
- 区别：
  - TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。
  - TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。
  - TCP面向字节流；UDP面向报文。
  - TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
  - UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
  - TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。
  - TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。
  - 基于TCP的应用：HTTP、WebSocker、重要数据文件传输等常见
  - 基于UDP的应用：QQ等部分实时通信软件、视频/音频下载传输等。

### 三次握手，4次挥手



- 三次握手
  - 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send状态。
  - 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态。
  - 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。
  - 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。
- 四次挥手
  - 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。
  - 第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。
  - 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK的状态。
  - 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
  - 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

### 状态同步,帧同步



帧同步和状态同步该怎么选（上）
https://zhuanlan.zhihu.com/p/104932624

帧同步和状态同步
https://zhuanlan.zhihu.com/p/33898014



### **帧同步和状态同步**

帧同步和状态同步是两种主流的游戏网络同步方案，核心区别在于同步的内容和实现方式：

1. **帧同步（Lockstep）** 同步操作指令而非游戏状态。所有客户端接收相同的输入序列，通过完全一致的逻辑本地计算游戏状态。优点是数据量极小、结果严格一致，适合RTS等需要绝对公平的游戏；缺点是对网络延迟敏感，一人卡顿全体等待。
2. **状态同步（State Sync）** 直接同步游戏对象的状态数据（如坐标、血量）。服务器作为权威方计算状态，客户端进行插值预测。优点是容错性强，适合FPS等实时游戏；缺点是带宽占用较高，可能出现预测误差修正。

选择依据：帧同步追求确定性，状态同步追求实时性，现代游戏常混合使用。



# 设计模式

### 六大设计模式



- 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。
- 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。
- 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。
- 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
- 迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。
- 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。





# 面试题

## [C#](https://zhida.zhihu.com/search?content_id=124074816&content_type=Article&match_order=1&q=C%23&zhida_source=entity)基础篇

- **请简述拆箱和装箱**

> 答：
> 装箱操作：
> 值类型隐式转换为object类型或由此值类型实现的任何接口类型的过程。
> 1.在堆中开辟内存空间。
> 2.将值类型的数据复制到堆中。
> 3.返回堆中新分配对象的地址。
> 拆箱操作：
> object类型显示转换为值类型或从接口类型到实现该接口值类型的过程。
> 1.判断给定类型是否是装箱时的类型。
> 2.返回已装箱实例中属于原值类型字段的地址。

- **C#中，string str = null 与 string str = ""，说明区别。**

> 答：
> string str = "" 初始化对象分配空间。
> string str = null 表示一个空引用,没有占用空间。

- **ref与out关键字**

> 答：
> ref 关键字使参数按引用传递。其效果是，当控制权传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。若要使用 ref 参数，则方法定义和调用方法都必须显式使用 ref 关键字。
> out 关键字会导致参数通过引用来传递。这与 ref 关键字类似，不同之处在于 ref 要求变量必须在传递之前进行初始化。若要使用 out 参数，方法定义和调用方法都必须显式使用 out 关键字。

- **什么是序列化？**

> 答：
> 序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。

- **sealed 修饰符有什么特点**

> 答：
>
> 1) sealed 修饰符可以应用于类、实例方法和属性。密封类不能被继承。密封方法会重写基类中的方法，但其本身不能在任何派生类中进一步重写。当应用于方法或属性时，sealed 修饰符必须始终与 override一起使用。
> 2) 将密封类用作基类或将 abstract 修饰符与密封类一起使用是错误的。
> 3) 结构是隐式密封的；因此它们不能被继承。

- **class和struct的异同**

> 答：
> 相同点：
>
> 1) 语法类似。
>
> 不同点：
>
> 1) class是引用类型，继承自System.Object类; struct是值类型，继承自System.ValueType类，因此不具多态性。但是注意，System.ValueType是个引用类型。
> 2) 从职能观点来看，class表现为行为; 而struct常用于存储数据。
> 3) class支持继承，可以继承自类和接口; 而struct没有继承性，struct不能从class继承，也不能作为class的基类，但struct支持接口继承。
> 4) 实例化时，class要使用new关键字; 而struct可以不使用new关键字，struct在声明时就进行了初始化过程，所有的成员变量均默认为0或null。

- **如何选择结构还是类。**

> 答：
>
> 1) 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。
> 2) 结构表示如点、矩形和颜色这样的轻量对象。例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。
> 3) 在表现抽象和多级别的对象层次时，类是最好的选择。
> 4) 大多数情况下该类型只是一些数据时，结构时最佳的选择。

- **抽象类（abstract class）和接口（interface）的区别。**

> 答：
> 抽象类：
>
> 1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法。
> 2) 抽象类不能被实例化。
> 3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类。
> 4) 具体派生类必须覆盖基类的抽象方法。
> 5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们。
>
> 接口：
>
> 1) 接口不能被实例化。
> 2) 接口只能包含方法声明。
> 3) 接口的成员包括方法、属性、索引器、事件。
> 4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员。
> 5) 接口中的所有成员默认为public，因此接口中不能有private修饰符。
> 6) 派生类必须实现接口的所有成员。
> 7) 一个类可以直接实现多个接口，接口之间用逗号隔开。
> 8) 一个接口可以有多个父接口，实现该接口的类必须实现所有父接口中的所有成员。
>
> 抽象类和接口的异同：
> 相同点：
>
> 1) 都可以被继承。
> 2) 都不能被实例化。
> 3) 都可以包含方法声明。
> 4) 派生类必须实现未实现的方法。
>
> 区别：
>
> 1) 抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。
> 2) 抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带able字段，证明其是表述一类“我能做。。。”。
> 3) 接口可以被多重实现，抽象类只能被单一继承。
> 4) 抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中。
> 5) 抽象类是从一系列相关对象中抽象出来的概念，因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定，因此反映的是事物的外部特性。
> 6) 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法。
> 7) 接口可以用于支持回调,而继承并不具备这个特点。
> 8) 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的。
> 9) 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法。

- **什么是强类型。**

> 答：
> 为所有变量指定数据类型称为“强类型”。C#是强类型语言。

- **什么是托管代码。**

> 答：
> 使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。

- **什么是CLR？**

> 答：
> CLR：公共语言运行库 Common Language Runtime。是一个运行时环境，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。

- **什么是委托？**

> 答：
>
> 1) 委托是一种引用方法的类型。
> 2) 委托类似于 C++ 函数指针，但它是类型安全的。
> 3) 委托允许将方法作为参数进行传递。
> 4) 委托可用于定义回调方法。

- **值类型和引用类型的区别。**

> 答：
>
> 1) 值类型通常被分配在栈上，它的变量直接包含变量的实例，使用效率比较高。
> 2) 引用类型分配在托管堆上，引用类型的变量通常包含一个指向实例的指针，变量通过该指针来引用实例。
> 3) 一个是值COPY，一个是地址COPY。

- **进程和线程的区别。**

> 答：
>
> 1) 进程是系统进行资源分配和调度的单位。
> 2) 线程是CPU调度和分派的单位。
> 3) 一个进程可以有多个线程，这些线程共享这个进程的资源。

- **造器Constructor是否可被override（重写）？**

> 答：构造器Constructor不能被继承，因此不能重写override，但可以被重载Overloade。

- **堆和栈的区别。**

> 答：
>
> 1) 栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。存放值类型。
> 2) 堆：一般由程序员分配释放。用new等分配内存函数分配得到的就是在堆上。存放引用类型。

- **在C#中using和new这两个关键字有什么意义。**

> 答：
> using 关键字有两个主要用途：
>
> 1) 作为指令，用于为命名空间创建别名或导入其他命名空间中定义的类型。
> 2) 作为语句，用于定义一个范围，在此范围的末尾将释放对象。
>
> new 关键字：新建实例或者隐藏父类方法

- **System.String 和System.StringBuilder有什么区别？**

> 答：
>
> 1) System.String是不可变的字符串。
> 2) System.StringBuilder存放了一个可变的字符串，并提供一些对这个字符串修改的方法。
> 3) String类在执行字符串拼接的操作上，用“+”会产生新的对象，占用内存。
> 4) StringBuilder类只是修改字符串的内容，不建立新的对象。

- **const和readonly有什么区别？**

> 答：
>
> 1) const 字段只能在该字段的声明中初始化。
> 2) 不允许在常数声明中使用 static 修饰符。
> 3) readonly 字段可以在声明或构造函数中初始化。因此，根据所使用的构造函数

- **C#中的委托是什么？事件是不是一种委托？**

> 答：
> 委托可以把一个方法作为参数代入另一个方法。
> 委托可以理解为指向一个函数的引用。
> 事件是一种特殊的委托。

- **能用foreach遍历访问的对象需要实现什么接口或声明什么方法的类型。**

> 答：声明IEnumerable接口或实现GetEnumerator()方法。

- **接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)？**

> 答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。

- **什么是虚函数？什么是抽象函数？**

> 答：
>
> 1) 虚函数：没有实现的，可由子类继承并重写的函数。
> 2) 抽象函数：规定其非虚子类必须实现的函数，必须被重写。

- **请简述ArrayList和List<>的主要区别**

> 答：
> ArrayList是非泛型列表，存储数据是把所有的数据都当成object类型数据，存在装箱问题，取出来使用的时候存在拆箱问题，装箱拆箱会使性能变差，而且存在数据安全问题，但是优点在于可以让值类型和引用类型相互转换。
> List是泛型列表，在使用的时候才会去定义数据类型，泛型避免了拆装箱的问题，存入读取熟读较快，类型也更安全。

- **反射的实现原理？**

> 答：
> 审查元数据并收集关於它的类型信息的能力,元数据(编辑后的基本数据单元)就是一大堆表，编译器会创建一个类定义表，一个字段定义表，一个方法定义表等,System.Reflection命名空间包含的几个类，允许你反射(解析)这些元数据的代码。

------

## Unity基础篇

- **一个角色要用到unity中寻路系统，应该添加哪个组件？**

> 答：NavMeshAgent。

- **NavMeshObstacle组件的作用？**

> 答：寻路网格动态碰撞组件，用于运动的物体阻碍寻路物体效果。

- **射线中[RaycastHit](https://zhida.zhihu.com/search?content_id=124074816&content_type=Article&match_order=1&q=RaycastHit&zhida_source=entity)代表什么？**

> 答：射线碰到的碰撞信息

- **通过什么可以区分射线碰到的游戏对象？**

> 答：通过LayerMask（层的遮罩），RaycastHit返回的碰撞的标签。

- **怎么判断两个平面是否相交?不能用碰撞体，说出计算方法。**

> 答：在两个平面上分别取一个向量，然后看是否相交。

- **[MeshCollider](https://zhida.zhihu.com/search?content_id=124074816&content_type=Article&match_order=1&q=MeshCollider&zhida_source=entity)和其他Collider的一个主要不同点？**

> 答：
> MeshCollider是网格碰撞器，对于复杂网状模型上的碰撞检测，比其他的碰撞检测精确的多，但是相对其他的碰撞检测计算也增多了，所以一般使用网格碰撞也不会在面数比较高的模型上添加，而会做出两个模型，一个超简模能表示物体的形状用于做碰撞检测，一个用于显示。

- **Unity3d中的碰撞器和触发器的区别？**

> 答：
>
> 1. 碰撞器物体不能互相进入到对方内部，触发器可以。
> 2. 触发器角色控制器可以使用，碰撞器中不能使用。
> 3. 触发器没有物理属性了，碰撞器可以有力存在。
> 4. 碰撞器调用OnCollisionEnter/Stay/Exit函数，触发器调用OnTriggerEnter/Stay/Exit函数。

- **物体发生碰撞的必要条件**

> 答：两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。

- **当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？**

> 答：穿透（碰撞检测失败）。
> 避免的方法：把刚体的实时碰撞检测打开Collision Detection修改为Continuous Dynamic

------

## 数据结构与算法篇

- **请使用冒泡排序，对一维数组进行降序排列**

> 答：
> 冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换。
> 冒泡排序算法的运作如下：
> 比较相邻元素。如果第一个比第二个大，就交换它们。
> 对每一对相邻元素做同样的工作，从开始第一队到结尾的最后一对。在这一点，最后的元素会使最大的数。
> 针对所有的元素重复以上的步骤，除了最后一个。
> 持续每次对越来越少的元素重复上面的步骤，知道没有任何一对数字需要比较。

写法1

```text
public void Bubble1(int[] a)
{
bool b;
int tmp;
for (int i = 0; i < a.Length; i++)
    {
	b = false;
for (int j = i+1; j < a.Length ; j++)
        {
if (a[j] > a[i])
           {
tmp = a[j];
a[j] = a[i];
a[i] = tmp;
              b = true;
            }
        }
if(!b)break;
    }
}
```

写法2

```text
void Bubble2(int[] a)
{
	bool b=false;
	int tmp;
	for(int i=0;i<a.Length;i++)
	{
		b=false;
		for(int j=0;j<a.Length-i;j++)
		{
			if(a[j]<a[j+1])
			{
				tmp=a[j];
				a[j]=a[j+1];
				a[j+1]=tmp;
				b=true;
			}
		}
		if(!b) break;
	}
}
```

写法3

```text
void Bubble3(int[] a)
{
	bool b=true;
	int j=0;
	int temp;
	do
	{
		b=false;
		for(int i;i<a.Length-j;i++)
		{
			if(a[i]<a[i+1])
			{
				temp=a[i];
				a[i]=a[i+1];
				a[i+1]=temp;
				b=true;
			}
		}
		j++;
	}
	while(b);
}
```

- **说出你所了解的数据结构，并说明它们的特点。**

> 答：
> 数组：长度固定，存储空间连续，读取速度快，插入，删除速度慢
> 链表：长度不定，存储空间可能不连续，读取速度慢，插入，删除速度快
> 栈：后进先出
> 队列：先进先出
> 字典：键/值对集合，无序，一一对应，查找速度快
> 树：可形成无限级层次，父子节点。

------

## 面向对象篇

- **请描述你所了解的设计模式，并说明在你的项目中哪里使用过？**

> 答：
> 单例: 对象池，游戏管理器
> 抽象工厂，
> 状态：有限状态机，
> 桥接：有限状态机
> 策略：AI自动行为操控中每种操控算法的独例

- **请说出4中面向对象的设计原则，并分别简述它们的含义。**

> 答：
> 1）单一职责原则：一个类，最好只做一件事，只有一个引起它的变化。
> 2）开放-封闭原则：对于扩展是开放的，对于更改是封闭的。
> 3）里氏替换原则：子类必须能够替换其基类。
> 4）依赖倒置原则：设计应该依赖于抽象而不是具体实现。
> 5）接口隔离原则：使用多个小的专门的接口而不要使用一个大的总接口。

------

## 网络篇

- **请简述TCP与UDP的区别。**

> 答：
> TCP是基于连接的，UDP基于无连接的
> TCP对系统资源的要求多，UDP较少
> UDP程序结构较简单
> TCP是面向流数据的，UDP是数据报
> TCP保证数据正确性，UDP可能丢包。
> TCP保证数据的顺序，UDP不保证。

- **UDP连接和TCP连接的异同。**

> 答：
>
> 1) TCP（Transmission Control Protocol）传输控制协议：一种面向连接的、可靠的、基于字节流的运输层通信协议，三次握手。
> 2) UDP（User Datagram Protocol）用户数据报协议：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点。缺点是易丢失数据包。

- **为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？**

> 答：
> 这是因为服务段的LISTEN状态下的SOCKET当收到SYN报文的建立请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发的。

------

## 3D数学篇

- **[四元数](https://zhida.zhihu.com/search?content_id=124074816&content_type=Article&match_order=1&q=四元数&zhida_source=entity)是什么？主要作用什么？对欧拉角的优点是什么？**

> 答：
> 所谓四元数，就是把4个实数组合起来的东西。4个元素中，一个是实部，其余3个是虚部
> 作用：四元数用于表示旋转
> 优点：
> 1）能进行增量旋转
> 2）避免万向锁
> 3）给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）
> 四元数不会有欧拉角存在的 gimbal lock 问题[万向节死锁]
> 四元数由4个数组成，旋转矩阵需要9个数
> 两个四元数之间更容易插值
> 四元数、矩阵在多次运算后会积攒误差，需要分别对其做规范化(normalize)和正交化 (orthogonalize)，对四元数规范化更容易
> 与旋转矩阵类似，两个四元组相乘可表示两次旋转

- **向量的点乘、叉乘以及归一化的意义？**

> 答：
> 1）点乘计算两个向量之间的夹角，还可表示某一方向的投影。
> 2）叉乘得到的是法向量。
> 3）标准化向量：用在只关系方向，不关心大小的时候。

------

## [Shader](https://zhida.zhihu.com/search?content_id=124074816&content_type=Article&match_order=1&q=Shader&zhida_source=entity)篇

- **写出光照计算中的diffuse的计算公式**

> 答：
> 实际光照强度l=环境光（lambient）+漫反射光（Idiffuse）+镜面高光（lspecular）
> 环境光：lambient=环境光强度（Aintensity）*环境光颜色（Acolor）
> 漫反射光：ldiffuse=镜面光照强度（Dintensity）*镜面光颜色（Scolor）*（光的反射向量（R）.观察者向量（V））^镜面光指数（n）

- **MeshRender中material和shader的区别？**

> 答：
> MeshRender是模型渲染的组件，有此组件物体才能显示出来
> Material是材质球，实际就是shader的实例，并进行赋值，贴图、纹理、颜色等。
> Shader是着色器，实际上是一段程序，还可以用来实现一些仅靠贴图不容易实现的效果，如玻璃。
> Shader大致分为：
> 1.表面着色器
> 2.顶点和片元着色器
> 3.固定功能着色器

- **alpha blend工作原理**

> 答：
> [Alpha Blend](https://zhida.zhihu.com/search?content_id=124074816&content_type=Article&match_order=1&q=Alpha+Blend&zhida_source=entity)是 实现透明效果，Color = 原颜色*alpha/255+目标色*（255-alpha）/255

- **光照贴图 的优势是什么？**

> 答：
> 1.使用光照贴图比使用实时光源渲染要快
> 2.可以降低游戏内存消耗
> 3.多个物体可以使用同一张光照贴图

## 博客

陆泽西 (Jesse Lu) http://www.luzexi.com/

慕容小匹夫 https://www.cnblogs.com/murongxiaopifu/category/635853.html

[(1 封私信 / 26 条消息) 【游戏开发面经汇总】-社招初级篇 - 知乎](https://zhuanlan.zhihu.com/p/8729305120)

### 面试题

Unity面试题（包含答案） - siki老师的文章 - 知乎 https://zhuanlan.zhihu.com/p/61925255

Unity游戏开发大厂真实面试题分享 - 妄想人间惊鸿宴的文章 - 知乎 https://zhuanlan.zhihu.com/p/451164476

[(1 封私信 / 26 条消息) 【游戏开发面经汇总】- 计算机基础篇 - 知乎](https://zhuanlan.zhihu.com/p/417640759)
