# C#

### 值类型和引用类型的区别
- 速度上的区别:值类型存取速度快，引用类型存取速度慢。
- 用途上的区别:值类型表示实际数据，引用类型表示指向存储在内存中的数据的指针或引用。
- 来源上的区别:值类型继承自System.ValueType，引用类型继承自System.Object
- 位置上的区别:值类型的数据存储在内存的栈中，引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。
- 类型上的区别:值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。
- 值类型和引用类型在内存上存储的地方不一样。值类型的值是存储在内存的栈当中。引用类型的值是存储在内存的堆中。
- 在传递值类型和传递引用类型的时候，传递方式不一样。值类型我们称之为值传递，引用类型我们称之为引用传递。
- 值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。
- 引用类型（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。

### 拆箱装箱
装箱（boxing）和拆箱（unboxing）是C#类型系统的核心概念.是不同于C与C++的新概念！,通过装箱和拆箱操作，能够在值类型和引用类型中架起一做桥梁.换言之,可以轻松的实现值类型与引用类型的互相转换,装箱和拆箱能够统一考察系统,任何类型的值最终都可以按照对象进行处理.
- 装箱 就是把“值类型”转换成“引用类型”(Object)
- 拆箱 就是把“引用类型”转换成“值类型”

### c#中的数组、ArrayList、List区别
https://www.cnblogs.com/newcapecjmc/p/6970220.html

- 数组

  - 在内存上连续存储查询很快
  - 在数组的两个数据间插入数据是很麻烦的，而且在声明数组的时候必须指定数组的长度，数组的长度过长，会造成内存浪费，过段会造成数据溢出的错误。如果在声明数组时我们不清楚数组的长度，就会变得很麻烦。

- ArrayList

  - 基本是解决了数组的问题，但引入了新的问题

  - ArrayList会把所有插入其中的数据当作为object类型来处理，在我们使用ArrayList处理数据时，很可能会报类型不匹配的错误，也就是ArrayList不是类型安全的。在存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损。

- **泛型List**

  - 在声明List集合时，我们同时需要为其声明List集合内数据的对象类型，避免了arraylist的问题

### C#中字典集合HashTable、Dictionary、ConcurrentDictionary三者区别
https://www.cnblogs.com/yinrq/p/5584885.html

- HashTable

- - 用于处理和表现类似key-value的键值对，其中key通常可用来快速查找，同时key是区分大小写；value用于存储对应于key的值。Hashtable中key-value键值对均为object类型，所以Hashtable可以支持任何类型的keyvalue键值对，任何非 null 对象都可以用作键或值。

    HashTable是一种散列表，他内部维护很多对Key-Value键值对，其还有一个类似索引的值叫做散列值(HashCode)，它是根据GetHashCode方法对Key通过一定算法获取得到的，所有的查找操作定位操作都是基于散列值来实现找到对应的Key和Value值的。

    散列函数(GetHashCode)让散列值对应HashTable的空间地址尽量不重复。

    当一个HashTable被占用一大半的时候我们通过计算散列值取得的地址值可能会重复指向同一地址，这就造成哈希冲突。

    *C#中键值对在HashTable中的位置Position= (HashCode& 0x7FFFFFFF) % HashTable.Length，C#是通过探测法解决哈希冲突的，当通过散列值取得的位置Postion以及被占用的时候，就会增加一个位移x值判断下一个位置Postion+x是否被占用，如果仍然被占用就继续往下位移x判断Position+2\*x位置是否被占用，如果没有被占用则将值放入其中。当HashTable中的可用空间越来越小时，则获取得到可用空间的难度越来越大，消耗的时间就越多。*

  

  - Dictionary<TKey, TValue> 泛型类提供了从一组键到一组值的映射。通过键来检索值的速度是非常快的，接近于 O(1)，这是因为 Dictionary<TKey, TValue> 类是作为一个哈希表来实现的。检索速度取决于为 TKey 指定的类型的哈希算法的质量。TValue可以是值类型，数组，类或其他。

    Dictionary是一种变种的HashTable,它采用一种分离链接散列表的数据结构来解决哈希冲突的问题。




### C#List(链表)Dictionary(字典)源码剖析[Unity内功修炼-C#进阶01] - 修勾的文章 - 知乎
https://zhuanlan.zhihu.com/p/634380627

### 抽象类和接口的异同
**相同点：**
1. 都不能被实例化
2. 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化

**不同点**

1. 接口只有定义，其方法不能再接口中实现，只有实现接口的类才能实现接口中定义的方    法，而抽象类的方法可以再抽象类中被实现。
2. 接口需要用implements实现,抽象类只能被继承（extends）。
3. 设计理念不同，接口是"has - a "，抽象类是"is -a "
4. 接口中定义的成员变量默认修饰符为public static final（静态不能被修改），而且必须      给其赋初值。抽象类可以有自己的数据成员变量，也可以有非抽象的成员变量，而且抽象类中的成员变量默认为default(本包可见)。抽象类中的方法前面有abstract修饰，不能用private、static、synchronize、native修饰，同时方法必须以分号结尾，不带花括号。

### 什么时候用对象什么时候用接口?
抽象类是对类的抽象，接口是对行为的抽象。
如果行为跨越不同类的对象，可使用接口，对于一些现实的类对象，用继承抽象类。
抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。


### in out ref
- in 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它类似于 ref 或 out 关键字，不同之处在于 in 参数无法通过调用的方法进行修改。
- out 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它与 ref 关键字相似，只不过 ref 要求在传递之前初始化变量。 它也类似于 in 关键字，只不过 in 不允许通过调用方法来修改参数值。 若要使用 out 参数，方法定义和调用方法均必须显式使用 out 关键字。
- ref该种类型的参数传递变量地址给方法（引用传递），传递前变量必须初始化。 该类型与out型的区别在与： 1）.ref型传递变量前，变量必须初始化，否则编译器会报错,而out型则不需要初始化 2）.ref型传递变量，数值可以传入方法中，而out型无法将数据传入方法中。换而言之，ref型有进有出，out型只出不进。

``` C#
class Test
{
    static void Main(string[] args)
    {
        InOutRef test = new InOutRef();
        string outString = "10"; // out在函数外也可以赋值
        string refString = "1"; // ref不初始化会报错
        test.Test(1, out outString,ref refString);
    }
}

class InOutRef
{
    public void Test(in int inTest ,out string outTest,ref string refTest)
    {

        outTest = "10"; // out在函数内不赋值会报错
    }
}
```

### C#反射
C#反射机制
https://zhuanlan.zhihu.com/p/41282759




### 委托
C#各种委托介绍
https://www.cnblogs.com/oneweek/p/11236811.html

### C#字符串复制
- 复制是通过Copy和CopyTo来实现的。string.Copy(要复制的字符串);CopyTo(要复制字符的起始位置(从第几个字符开始往后复制（不包括第几个字符）)，目标字符数组，目标数组中的开始存放位置，要复制的字符个数);

### 介绍const？const修饰成员函数时放在哪？

`const` 表示**编译时常量**：值在编译期就确定，编译器在引用处直接把字面值嵌入到调用方代码或元数据

- 修饰不变常量，在编译的时候就需要有确定的值，只能用于数值和字符串，或者引用类型只能为null，struct也不能用const标记。const可以修饰class的字段或者局部变量，不能修饰属性。而readonly仅仅用于修饰class的字段，不能修饰属性。const是属于类级别而不是实例对象级别，不能跟static一起使用。而readonly既可以是类级别也可以是实例级别，它可以与static一起使用。
- readonly是只读的意思，表示不能进行写操作。最重要的是它在程序运行时才会去求值。它可以是任意类型，当然可以是object，数组，struct，它必须在构造函数或者初始化器中初始化，初始化完成之后不能被修改。通常可以定义一个readonly值为DateTime的常量。而const却无法指定为DateTime类型。
- 只有C#内置类型（int,double,long等）可以声明为const;结果、类和数组不能声明为const。
- readonly 是在字段上使用的修饰符，直接以类名.字段访问。
- const 必须在申明中初始化。之后不能再修改。
- readonly可以在申明中初始化，也可以在构造函数中初始化，其它情况不能修改。

### 函数可以返回引用吗？为什么？
- 引用就是变量的别名，操作一个变量的引用也就相当于操作变量本身，这一点跟指针很类似，但是操作引用不用像操作指针一样，利用取地址符号，很不方便。而操作引用的话，则跟操作普通变量一样，所以C++之中更加鼓励使用引用。
- C语言之中大量利用指针作为形参或者函数返回值，这是由于值拷贝会有很大的消耗（比如传入传出一个大的结构体）。所以在C++之中使用引用作为函数参数和返回值的目的和使用指针是一样的。而且形式上更加直观，所以C++提倡使用引用。
- 使用引用当作函数参数和返回值，效率更高。
- 函数返回的对象引用，必须在调用函数前就已经存在，不允许返回局部变量的引用！
- 当不希望返回的对象被修改的时候，可以添加const。

### 结构体和类的区别
- 类是引用类型，结构是值类型。
- 结构不支持继承。
- 结构不能声明默认的构造函数。

### 常用数据结构时间复杂度
![](img/时间复杂度.png)

### 闭包

当发生闭包时是这样的现象——先是捕获到变量，把它的存储位置提取出来让闭包内外都可以访问到；然后编译器将生成一个私有的匿名封装类，将捕获到的变量作为字段，lambda的方法体作为类的实例方法，返回的委托指向这个实例对象的函数，因此啊这个对象存储在堆上。

**概念**
内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。但该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。

**条件**
闭包是将一些执行语句的封装，可以将封装的结果像对象一样传递，在传递时,这个封装依然能够访问到原上下文。 
  形成闭包有一些值得总结的非必要条件： 
  1、嵌套定义的函数。 
  2、匿名函数。 
  3、将函数作为参数或者返回值。 
  4、在.NET中，可以通过匿名委托形成闭包：函数可以作为参数传递，也可以作为返回值返回，或者作为函数变量。而在.NET中，这都可以通过委托来实现。这些是实现闭包的前提。

### C# GC
**基本概念**

- CLR: Common Language Runtime, 公共语言运行时，是一种可以支持多种语言的运行时，其基本的核心功能包含:
    - 内存管理
    - 程序集加载和卸载
    - 类型安全
    - 异常处理
    - 线程同步

![f46ea4a64f73e366de414ff73fc9b178.png](img/4888_1.png)
- 托管模块的基本组成:
    - PE32/PE32+(64位)
    - CLR头
    - 元数据
    - IL代码(托管代码)
    
- 引用类型和值类型
    - 这部分略过，基本都有相关的认识，本质是看其分配的内存位于内存堆上还是栈上。
    - 每个进程会分配一个对应的进程堆，这就是我们常说的程序内存申请区域，不同进程是不会有交叉的。在堆上还是在栈上进行内存分配，是没有速度差异的，都很快。
    
- 垃圾回收器(Garbage Collector)
    - 在CLR中的自动内存管理，就会使用垃圾回收器来执行内存管理，其会定时执行，或者在申请内存分配是发现内存不足时触发执行，也可以手动触发执行(System.GC.Collect)
    - 垃圾回收的几种基本算法
        - 标记清除算法(Mark-Sweep)关键点是，清除后，并不会执行内存的压缩
        - 复制算法(Copying) 内存等额划分，每次执行垃圾回收后，拷贝不被回收的内存到没有被使用的内存块，自带内存压缩，弊端是内存浪费大(每次只能使用部分，预留部分给拷贝使用)
        - 标记整理算法(Mark-Compact)关键点，清除后，会执行内存压缩，不会有内存碎片
        - 分代收集算法(Generational Collection)对内存对象进行分代标记，避免全量垃圾回收带来的性能消耗。下文会详细讲解。

**垃圾回收模型**

- 垃圾回收的目的
    - 缘由： 内存是有限的，为了避免内存溢出，需要清理无效内存
- 触发时机
    - 申请分配内存时内存不足(本身不足或者内存碎片过多没有足够大小的内存片)
    - 强制调用System.GC.Collect
    - CLR卸载应用程序域(AppDomain)
    - CLR正在关闭(后面2种在进程运行时不会触发)
- 垃圾回收的流程
    - GC准备阶段 暂停进程中的所有线程，避免线程在CLR检测根期间访问堆内存
    - GC的标记阶段 首先，会默认托管堆上所有的对象都是垃圾(可回收对象)，然后开始遍历根对象并构建一个由所有和根对象之间有引用关系的对象构成的对象图，然后GC会挨个遍历根对象和其引用对象，如果根对象没有任何引用对象(null)GC会忽略该根对象。对于含有引用对象的根对象以及其引用对象，GC将其纳入对象图中，如果发现已经处于对象图中，则换一个路径遍历，避免无限循环。PS： 所有的全局和静态对象指针是应用程序的根对象。
    - 垃圾回收阶段 完成遍历操作后，对于没有被纳入对象图中的对象，执行清理操作
    - 碎片整理阶段 如果垃圾回收算法包含这个阶段，则会对剩下的保留的对象进行一次内存整理，重新归类到堆内存中，相应的引用地址也会对应的整理，避免内存碎片的产生。
    

![c9080d88c233905b46803105fc1ba3d4.png](img/4890_1.png)

- 分代垃圾回收的过程
    - 分代的基本设计思路:
        - 对象越新，生命周期越短，反之也成立
        - 回收托管堆的一部分，性能和速度由于回收整个托管堆
    - 基本的分代: 0/1/2：
        - 0代: 从未被标记为回收的新分配对象
        - 1代: 上一次垃圾回收中没有被回收的对象
        - 2代: 在一次以上的垃圾回收后任然未被回收的对象
    - 低一代的GC触发，移动到高一代后，未必会触发高一代的GC，只有高一代的内存不足时才会触发高一代的GC
    - 不同代的自动GC频率是可以设置的，一般0:1:2的频率为100：10：1

- 操作图解释分代的过程:

![c2946fc2ec499605030049306eef61c0.png](img/4892_1.png)

![93715a475185a503e7beecd808e743e8.png](img/4894_1.png)


-  非托管对象的回收
    - 对于非托管对象的管理，不受CLR的自动内存管理操作，这部分需要借鉴CLR的自动管理或者手动执行内存回收，这就是两种非托管对象的管理方式: Finalize和Dispose
    - 非托管资源: 原始的操作系统文件句柄，原始的非托管数据库连接，非托管内存或资源

- Finalize
    - System.Object定义了Finalize()虚方法，不能用override重写，其写法类似c++的析构函数:
``` C#
class Finalization{
    ~Finalization()
    {
        //这里的代码会进入Finalize方法
        Console.WriteLine("Enter Finalize()");
    }
}
```

- 转换的IL:

    ![6e65ed60af2d7c62490f0dc834fbf47f.png](img/4896_1.png)
    - 基类方法放入到Finally中，其本质还是交给GC进行处理，只是其执行的时间不确定，是在GC完后在某个时间点触发执行Finalize方法，使用这个方法的唯一好处就是: 非托管资源是必然会被释放的。



- IDisposable
    - 继承了该接口，则需要实现Disposable接口，需要手动调用，这就确保了回收的及时性，对应的问题是如果不显示调用Dispose方法，则这部分非托管资源是不会被回收的。
    - c#中的using关键字，转换成IL语句，就是内部实现了IDispoable方法，最终的try/finally中，会在finally中调用dispose方法。

- Unity中的C# GC
    - 目前unity2018.4还是 Boehm–Demers–Weiser garbage collector， unity2019.1 中已经开始引入: Incremental Garbage Collection增量式垃圾回收功能,
    - 相关链接: https://www.gamefromscratch.com/post/2018/11/27/unity-add-incremental-garbage-collection-in-20191.aspx



## **Unity GC（垃圾回收）**

参考链接：

[https://www.bilibili.com/video/BV1BJ4m1u7h4/?spm_id_from=333.1387.favlist.content.click&vd_source=814330d3527237342cf943b532e345a5](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1BJ4m1u7h4/%3Fspm_id_from%3D333.1387.favlist.content.click%26vd_source%3D814330d3527237342cf943b532e345a5)

[https://docs.unity3d.com/cn/2019.4/Manual/UnderstandingAutomaticMemoryManagement.html](https://link.zhihu.com/?target=https%3A//docs.unity3d.com/cn/2019.4/Manual/UnderstandingAutomaticMemoryManagement.html)

GC就是**定位和释放未使用内存的过程**，是一种自动内存管理机制，它会在程序运行时持续监控内存使用情况，自动识别并释放不再被程序使用的对象所占用的内存空间，从而防止内存泄漏并简化开发者的内存管理工作

**针对内存区域：**内存中的堆区域，在堆区域分配内存再通过指针访问的类型称为引用类型，引用类型包括：对象、字符串、数组

**为什么使用GC：**

1）C/C++不支持GC，需要手动管理内存，用new()申请内存delete()释放

2）手动管理内存经常会忘记释放申请的内存，导致内存泄漏，更严重可能会出现内存溢出

3）使用GC减少了编码工作，也大大降低了内存泄漏的可能性

**UnityGC的执行流程：**

1）遍历内存中的所有对象，检查每个对象是否被其他对象引用

2）将没有被其他对象引用的对象标记为可释放

3）释放所有被标记的对象

### **核心机制**

**分代回收机制（Generational GC）：**

将堆内存分为三代，基于对象存活时间的不同来分级回收：

- 第0代

- - 存储新创建的短期对象（如临时对象、每帧生成的例子特效）
  - 回收频率最高：第0代堆满时立即触发
  - 存活对象晋升：未被回收的对象会被晋升到第1代

- 第1代

- - 存储从第0代晋升的中期对象（如存活较久的游戏实体）
  - 回收频率中等：当第0代回收后内存仍不足时触发（连带回收第0代）

- 第2代

- - 存储长期存活的大对象（如全局管理器、静态资源）
  - 回收成本最高：仅当第0/1代回收仍不足时触发全堆回收

**增量式GC（Incremental GC）**

- 将单次GC操作分摊到多帧执行，减少卡顿
- 适用于开发世界、大型游戏避免GC导致的帧率骤降

### **触发时机**

Unity GC的触发是由内存分配需求驱动的

**(1) 自动触发**

- 第0代堆满：立即触发第0代GC
- 第1/2代堆满：逐级触发更高代回收
- 低内存状态：系统内存紧张时可能提前触发GC

**(2) 手动触发**

- `System.GC.Collect()`：强制触发全堆回收
- 使用场景：场景切换、加载大型资源

**(3) 特殊触发点**

- 卸载未用资源：`Resources.UnloadUnuseAssets()`
- 卸载AssetBundle：`AssetBundle.Unload(true)`

### **问题**

每当Unity需要执行GC时，它会停止运行程序代码并且在GC完成后才恢复运行，此中断可能会导致游戏延迟，持续时间取决于回收内存的大小以及游戏运行的平台，这带来了帧率不稳的问题。

下面时一些导致GC使用不当的代码

1）高频字符串拼接

```csharp
void Update() {
    string text = "HP:" + hp + "/" + maxHp; // 每次拼接生成新字符串 → 第0代堆快速填满
}
```

2）未缓存组件引用

```csharp
void Update() {
    GetComponent<Rigidbody>().velocity = Vector3.forward; // 每次调用可能产生GC
}
```

3）滥用Instantiate/Destroy

```csharp
void Shoot() {
    var bullet = Instantiate(bulletPrefab); // 分配内存
    Destroy(bullet, 2f); // 产生GC垃圾
}
```

4）协程中频繁yield new对象

```csharp
IEnumerator Flash() {
    while (true) {
        yield return new WaitForSeconds(1f); // 每次new对象 → GC
    }
}
```

5）值类型装箱

```csharp
int score = 100;
object boxedScore = score; // 装箱 → 堆分配
```

### **优化**

**卡顿原因**：1）高频0代回收；2）耗时全队回收（2代回收）

**优化整体思路：**1）不new不GC（减少分配）；2）能复用不创建（对象池）；3）该出手时就出手（手动GC）

**（1）避免高频临时对象分配**

- 用`StringBuilder` 代替字符串拼接
- 缓存组件引用（只调用`GetComponent`一次）
- 避免在Update中`new`对象

**（2）使用对象池**

- 子弹/敌人/特效等高频创建对象
- 复用对象代替`Instantiate/Destroy`

```text
// 对象池伪代码
public class ObjectPool {
 private Queue<GameObject> _pool = new Queue<GameObject>();

 public GameObject Get() {
 return _pool.Count > 0 ? _pool.Dequeue() : Instantiate(prefab);
    }

 public void Return(GameObject obj) {
 obj.SetActive(false);
 _pool.Enqueue(obj);
    }
}
```

**（3）值类型处理（避免装箱）**

- 使用`List<int>`代替`ArrayList`
- 避免值类型转`Object`接口

```text
/ ❌ 装箱（GC警告）
int health = 100;
object boxed = health; 

// ✅ 无GC方案
List<int> healthList = new List<int>(); // 泛型集合
healthList.Add(health); 
```

**（4）手动GC**

- 切换场景时主动调用

```text
IEnumerator LoadLevel() {
 Resources.UnloadUnusedAssets();
 GC.Collect(); // 主动触发
 yield return null; // 等待GC完成
 SceneManager.LoadScene("Level2");
}
```

**性能监控：**可以使用Unity Profiler来查看想能，定位脚本发生问题的代码位置






# Lua

### Lua 元表

菜鸟教程:https://www.runoob.com/lua/lua-metatables.html

lua的元表以及多继承:https://www.jianshu.com/p/3eaa69a6d0a2


### Lua GC

**基本数据结构**
lua的基本数据结构: union + type
``` lua
typedef union Value{
    GCObject* gc;   //gc object
    void* p;       // light userdata
    int b;         // booleans
    lua_CFunction f; // light c functions
    lua_Integer i;   //integer number 5.1为double，5.3为long long 8个字节
    lua_Number n;   // double number 5.3 为double 8个字节
} Value;

struct lua_Value{
    Value value_;
    int tt_;
} TValue;
```
对于所有的需要被GC的对象，都会放在GCObject组成的链表中


**GC算法和流程**

1.双色标记清除算法
在Lua5.0中的GC，是一次性不可被打断的操作，执行的算法是Mark-and-sweep算法，在执行GC操作的时候，会设置2种颜色，黑色和白色，然后执行gc的流程，大体的伪代码流程如下:



``` c
每个新创建的对象为白色

//初始化阶段
遍历root链表中的对象，并将其加入到对象链表中    

//标记阶段   
当前对象链表中还有未被扫描的元素:    
    从中取出对象并将其标记为黑色   
    遍历这个对象关联的其他所有对象: 
        标记为黑色
        
//回收阶段
遍历所有对象:   
    如果为白色:   
        这些对象没有被引用，则执行回收
    否则: 
        这些对象仍然被引用，需要保留
```
整个过程是不能被打断的，这是为了避免一种情况：
如果可以被打断，在GC的过程中新创建一个对象
那么如果标记为白色，此时处于回收阶段，那么这个对象没有被扫描就会被回收；
如果标记为黑色，此时处于回收阶段，那么这个对象没有被扫描就会被保留
两种情况都不适合，所以只有让整个过程不可被打断，带来的问题就是造成gc的时候卡顿

**三色标记清除算法**
虽然是三色，本质是四色，颜色分为三种:
- 白色: 当前对象为待访问状态，表示对象还未被gc标记过，也就是对象创建的初始状态； 同理，如果在gc完成后，仍然为白色，则说明当前对象没有被引用，则可以被清除回收
- 灰色: 当前对象为待扫描状态，当前对象已经被扫描过，但是其引用的其他对象没有被扫描
- 黑色: 当前对象已经扫描过，并且其引用的其他对象也被扫描过

其流程伪代码:
``` c
每个新创建的对象为白色

//初始化阶段   
遍历root阶段中引用的对象，从白色设置为灰色，并放入到灰色节点列表中   

//标记阶段    
当灰色链表中还有未被扫描的元素:    
    从中去除一个对象并将其标记为黑色   
    遍历这个对象关联的其他所有对象:   
        如果是白色:
            标记为灰色，并加入灰色链表中   
            
//回收阶段  
遍历所有对象:   
    如果为白色: 
        这些对象没有被引用，需要被回收
    否则:
        重新加入对象链表中等待下次gc   
整个标记过程是可以被打断的，被打断后回来只需要接着执行标记过程即可，回收阶段是不可被打断的。
```
如何解决在标记阶段之后创建的对象为白色的问题?
分裂白色为两种白色，一种为当前白色 currentwhite， 一种为非当前白色 otherwhite，新创建的对象都为otherwhite，则在执行回收的时候，如果为otherwhite则不执行回收操作，等待下次gc的时候，会执行白色的轮换，则新创建的对象会进入下一轮gc。

**lua gc的一些关键点**
1.初始化阶段的操作原理
以前我一直理解这个root就是将gcobject的链表进行转换到灰色链表中，其实并不是，而是去对当前虚拟机中的mainthread表, G表， registry表进行操作，其函数为:
``` c
static void markroot(lua_State * L)
{
    global_State *g = G(L);
    g->gray = NULL;
    g->grayagain = NULL;
    g->weak = NULL;
    //标记几个入口
    markobject(g, g->mainthread);
    markvalue(g, gt(g->mainthread));
    markvalue(g, registry(L));
    markmt(g);
    g->gcstate = GCSpropagte;
}
```
markobject/markvalue都是将对象从白色标记为灰色，所以这里面还有效的数据，就会最终进行扫描标记，如果最终不是白色，则会被保留，而执行回收操作的时候，是对gclist进行操作的，只要是currentwhite，那么就是可以被回收的。

2.对于中途创建的对象的颜色处理
这儿会分为两种，前向操作和后退操作:
- 前向操作: 新创建对象为白色，被一个黑色对象引用，则将当前新创建对象标记为灰色
- 后退操作: 新创建对象为白色，被黑色对象引用，该黑色对象退回到灰色，塞入到grayagain表中，后续一次性扫描处理

对大部分数据，都是前向操作，对于table类型数据，则如果其新创建对象，该table会回退到灰色塞入到grayagain表中。
本质没区别，主要是table属于频繁操作的对象，如果反复将table中新创建的对象都设置成灰色，则灰色链表会容易变得很大，所以为了提高性能，就将table塞入到grayagain表中，后续一次性处理即可。



### Lua pairs和ipairs的区别
lua中pairs和ipairs的区别:https://blog.csdn.net/Memoryuuu/article/details/85067701





# UGUI 

### **底层原理**

参考链接：[https://www.bilibili.com/video/BV17W4y1d7dY?spm_id_from=333.788.player.switch&vd_source=814330d3527237342cf943b532e345a5&p=4](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV17W4y1d7dY%3Fspm_id_from%3D333.788.player.switch%26vd_source%3D814330d3527237342cf943b532e345a5%26p%3D4)

（关于这方面的理解仍需加强）

UGUI的作用主要在于两方面：1）显示 2）交互

显示，抽象的来说就是：我们在屏幕中看到的UI的图形和布局；包括：1）图形的渲染，从3维到2维再到显示在屏幕上 2）UI元素控件布局，尺寸调整

交互，抽象的说就是：收到一件事情，让谁去干这件事，怎么干这件事；包括：1）输入 2）射线检测 3）控件事件交互

显示和交互一共包含的五个步骤，就是我们UGUI的核心类继承关系图，如下图，分别有五个模块：

1）输入模块BaseInputModule；2）射线检测模块BaseRayCaster；3）交互模块Selectable；4）布局模块LayoutGroup；5）图形模块Graphic

![img](https://pic1.zhimg.com/v2-7dbc51caf6d46c6f561195da869046b6_1440w.jpg)

仅仅有了UGUI核心的五个类模块还不行，我们需要让他们修调运作。在场景中创建Canvas时，还会自动创建一个[EventSystem](https://zhida.zhihu.com/search?content_id=256634224&content_type=Article&match_order=1&q=EventSystem&zhida_source=entity)，即我们创建UI时会有两个大的**实体**：Canvas和EventSystem；还记得刚才说的UGUI的两个大作用1）显示 2）交互，实际上EventSystem就负责管理 交互，Canvas和CanvasUpdateRegistry（一个静态服务类）就负责 显示；以**EventySystem**、**Canvas**、**CanvasUpdateRegitry**三者为核心，组织调度了UGUI的五个类模块，使其协同运作，组成了UGUI显示和交互的循环往复，这五个模块的顺序如下

![img](https://pic2.zhimg.com/v2-fcfaa4a8de4af9f2a4e4b392a7699967_1440w.jpg)

我们具体来说一说三个核心EventSystem、Canvas、CanvasUpdateRegistry

**EventSystem**

EventSystem是一个实体，负责管理UI的交互，作用包括：1）输入处理，将输入处理转换作为逻辑事件；2）射线检测，通过GraphicRaycaster确定命中的UI元素；3）状态管理，控制Seclectable的交互状态（如按钮按下或禁用状态）；每个场景只需要一个EventSystem实体即可

**CanvasUpdateRegistry**

CanvasUpdateRegistry是一个静态状态类，负责UI的更新，作用包括：1）脏标记管理，记录需要更新的UI元素；2）批量更新，在帧末统一处理所有更新请求；3）优先级控制，确保计算布局再更新图形

**Canvas**

Canvas是一个实体，是UI元素的物理承载和渲染终端，作用包括：1）渲染空间定义，决定UI显示在屏幕空间/世界空间；2）合批绘制，将相同材质的UI在同一批绘制；3）渲染控制，通过CanvasRender将网格数据提交给GPU

以这三者为核心，上图流程便可概括为：交互 -> 更新 -> 渲染，具体的代码执行流程如下

```text
Unity主循环
├─ EventSystem.Update()                          # 交互事件处理入口
│   ├─ StandaloneInputModule.Process()          // 输入模块（阶段1）
│   │   ├─ ProcessMouseEvent()                  → 生成PointerEventData
│   │   │   ├─ GetMousePointerEventData()       // 获取鼠标状态
│   │   │   └─ ExecuteEvents.Execute()          // 触发事件回调
│   │   │
│   │   └─ ProcessTouchEvent()                  → 处理触摸输入
│   │       ├─ GetTouchPointerEventData()       // 转换触摸数据
│   │       └─ ProcessMove/Press/Drag()         // 处理触摸阶段
│   │
│   └─ GraphicRaycaster.Raycast()               // 射线检测
│       ├─ 遍历所有raycastTarget=true的UI元素
│       └─ 返回按depth排序的命中列表
│
├─ CanvasUpdateRegistry.BeginFrame()            # 更新调度入口
│   ├─ PerformUpdate()                          // 关键更新入口（阶段2-3）
│   │   ├─ 布局阶段（阶段2）
│   │   │   ├─ LayoutRebuilder.Rebuild()        
│   │   │   │   ├─ CalculateLayoutInput()       // 水平/垂直计算
│   │   │   │   │   ├─ minWidth/preferredWidth计算
│   │   │   │   │   └─ 子元素间距处理
│   │   │   │   │
│   │   │   │   └─ SetLayout()                  // 应用布局
│   │   │   │       ├─ SetChildAlongAxis()      // 定位子元素
│   │   │   │       └─ 处理Padding/Spacing
│   │   │   │
│   │   │   └─ ContentSizeFitter.OnRectTransformDimensionsChange()
│   │   │       └─ 自适应尺寸调整
│   │   │
│   │   ├─ 图形阶段（阶段3）
│   │   │   ├─ Graphic.Rebuild()               
│   │   │   │   ├─ OnPopulateMesh()             // 生成顶点数据
│   │   │   │   │   ├─ Text生成文字网格
│   │   │   │   │   └─ Image生成UV坐标
│   │   │   │   │
│   │   │   │   └─ UpdateGeometry()             // 提交GPU
│   │   │   │       ├─ canvasRenderer.SetMesh()
│   │   │   │       └─ 材质/纹理绑定
│   │   │   │
│   │   │   └─ MaskableGraphic.UpdateMaterial() // 遮罩处理
│   │   │       └─ 处理Stencil缓冲
│   │   │
│   │   └─ 脏数据清理
│   │       ├─ 清空布局重建队列
│   │       └─ 清空图形重建队列
│   │
│   └─ Canvas.SendWillRenderCanvases()          // 预渲染回调
│
└─ Rendering管线                                # 最终输出（阶段4）
    ├─ CanvasRenderer.OnRender()                // 合批绘制
    │   ├─ 动态合批处理
    │   │   ├─ 合并相同材质的UI元素
    │   │   └─ 生成最优DrawCall
    │   │
    │   └─ 提交GPU指令
    │       ├─ 设置渲染状态
    │       └─ 调用GL/DirectX API
    │
    └─ 根据RenderMode处理输出
        ├─ ScreenSpace-Overlay → 直接绘制到屏幕
        ├─ ScreenSpace-Camera → 通过指定相机渲染
        └─ WorldSpace → 3D空间渲染
```

### **Canvas渲染模式**

Canvas主要有三种渲染模式：

1）Screen Space -Overlay(屏幕空间-覆盖)：

- UI直接覆盖在屏幕最上层，无视3D场景
- 无需摄像机，性能最高，适合纯2D UI
- UI元素自动适配屏幕分辨率

2）Screen Space -Camera(屏幕空间-摄像机)

- UI通过指定摄像机渲染，可以结合3D场景
- UI元素受摄像机参数影响，但始终面向摄像机
- 支持UI与3D物体的交互（如遮挡）

3）World Space(世界空间)

- UI作为3D场景中的物体，可自由旋转、缩放
- 需手动设置RectTransform的位置和大小
- 性能较低，适合少量动态UI

### **UGUI打包图**

1）启用Sprite Packer

Edit -> Project Settings -> Editor -> Sprite Packer Mode -> Always Enabled

2）创建Sprite Atlas文件

project文件夹 -> Create -> 2D -> Atlas文件

3）添加精灵到图集

选中Atlas文件 -> Inspector -> Object for Packing中拖入精灵或文件夹

4）配置参数

- **Padding**: 2-4像素（防边缘渗色）
- **Compression**: 移动端选`ASTC 4x4`，PC选`BC7`
- **Allow Rotation**: 关闭（避免UI错位）
- **Include in Build**: 勾选（否则运行时失效）

5）代码动态加载

```csharp
public SpriteAtlas atlas;
Image image;
void Start() {
    image.sprite = atlas.GetSprite("icon_name");
}
```

### **Image和RawImage的区别**

在Unity UGUI中，**Image** 和 **RawImage** 都是用于显示2D图像的基础组件，但它们在功能、性能和使用场景上有显著区别。以下是详细对比：

| 特性         | Image                              | RawImage                          |
| ------------ | ---------------------------------- | --------------------------------- |
| 适用纹理类型 | 仅支持Sprite（需导入为Sprite类型） | 支持任意Texture2D/RenderTexture等 |
| UV控制       | 不支持UV偏移/缩放                  | 支持动态调整UV（uvRect参数）      |
| 性能         | 更高（针对UI优化）                 | 较低（灵活性强但开销大）          |
| 材质支持     | 默认使用UI材质，可自定义           | 需手动指定材质                    |
| 多平台兼容性 | 自动适配Sprite的压缩格式           | 需手动处理纹理压缩                |







# UnityEngine

### **AB包**

#### **基本概念**

**是什么：** AB包是Unity的资源动态加载技术，将游戏资源（场景、模型、贴图等）打包成独立文件，运行时按需记载，实现热更新、减小安装包体积

**为什么：**

1）安装包过大：传统打包需要把所有资源塞进安装包，体积过大；AB包只需放核心资源，非必要资源后续下载

2）无法热更新：传统更新修复BUG需重新上交应用商店审核；AB包更新直接替换服务器上的AB包，玩家重启游戏后立即生效

3）内存浪费：传统加载`Resources.load`一次性加载所有资源，内存占用高；AB包按需加载/卸载，动态管理内存

### **用法**

1. 标记资源（设置AB包名称）：选中资源，Inspector窗口底部设置AssetBundle名称
2. 打包AB包（Build）：注意参数

- `BuildAssetBundleOptions`（压缩方式）：1）`None`（无压缩加载快，但体积大）；2）`LZMA`（高压缩，需解压，适合下载）；3）`LZ4`（快速加载，适合运行时）
- `BuildTarget`（目标平台）：选择匹配的目标平台（如Android、iOS、StandaloneWindows）
- 加载AB包（运行时）：可以从本地（StreamingAssets）或 服务器（热更新）加载

- - 从本地加载（适用于初始资源）

```text
using UnityEngine;

public class LoadABFromLocal : MonoBehaviour {
 void Start() {
 string path = Path.Combine(Application.streamingAssetsPath, "AssetBundles/characters.unity3d");
 
 // 同步加载
 AssetBundle ab = AssetBundle.LoadFromFile(path);
 GameObject playerPrefab = ab.LoadAsset<GameObject>("Player"); // 加载预制体
 Instantiate(playerPrefab);

 // 异步加载（推荐，避免卡顿）
 StartCoroutine(LoadABAsync(path));
    }

 IEnumerator LoadABAsync(string path) {
 AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);
 yield return request;

 AssetBundle ab = request.assetBundle;
 GameObject playerPrefab = ab.LoadAsset<GameObject>("Player");
 Instantiate(playerPrefab);
    }
}
```

- - 从服务器上下载（热更新）

```text
using UnityEngine;
using UnityEngine.Networking;

public class LoadABFromWeb : MonoBehaviour {
 void Start() {
 StartCoroutine(DownloadAB("http://yourserver.com/AssetBundles/weapons.unity3d"));
    }

 IEnumerator DownloadAB(string url) {
 UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(url);
 yield return request.SendWebRequest();

 if (request.result == UnityWebRequest.Result.Success) {
 AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request);
 GameObject weaponPrefab = ab.LoadAsset<GameObject>("Sword");
 Instantiate(weaponPrefab);
        } else {
 Debug.LogError("下载失败: " + request.error);
        }
    }
}
```

4. 卸载AB包（释放内存）

```text
// 卸载单个AB包（false = 只卸载AB包，不销毁已加载的资源）
ab.Unload(false); 

// 彻底卸载（true = 卸载AB包 + 销毁所有加载的资源，慎用！）
ab.Unload(true); 

// 强制清理未使用的资源（类似GC）
Resources.UnloadUnusedAssets();
```

### **依赖**

**是什么：** AB包依赖指的是多个资源包的引用关系。比如，角色模型（`character.ab`）使用了公共材质（`material.ab`），那么`character.ab`就依赖`material.ab`，如果不先加载材质包，角色就会变成“紫色丢失状态”。

**依赖管理的核心方法：**

Unity打包时会自动生成一个总清单文件（AssetBundleManifest），记录所有AB包的依赖关系，加载时需要：

1）先加载这个清单

2）通过`GetAllDependencies()`获取依赖列表

3）递归加载所有依赖的AB包

4）最后加载AB包

### **Addressable**

**是什么：** Addressable（可寻址资源系统）是Unity官方推出的**资源管理框架**，基于AssetBundle但更高级，主要解决：

1）自动处理依赖关系，不同手动加载依赖的AB包

2）简化热更新流程，内置版本对比和下载

3）内存管理自动化，自动卸载不用的资源

4）支持异步加载，不卡主线程

**核心思想：**给每个资源分配唯一地址，通过地址加载资源，无需关心底层是AB包还是本地资源







# 优化









# 图形学









# 算法

 







# 网络







# 面试题

